==================== FILE: lib\firebase_options.dart ====================
// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyBB7AOt_tblA7kuL4lyaWP_eJJFy7ps24U',
    appId: '1:250945452144:web:96c9156892ca202698dcb5',
    messagingSenderId: '250945452144',
    projectId: 'memoraapp-c5a0a',
    authDomain: 'memoraapp-c5a0a.firebaseapp.com',
    storageBucket: 'memoraapp-c5a0a.firebasestorage.app',
    measurementId: 'G-1YFY0H8WGJ',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyAlUpL1VPUAQmJK9RPbLYAGlQucezU7hyw',
    appId: '1:250945452144:android:e612ddfe8c8c0f3c98dcb5',
    messagingSenderId: '250945452144',
    projectId: 'memoraapp-c5a0a',
    storageBucket: 'memoraapp-c5a0a.firebasestorage.app',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyBJxq-z0d0PgbGzrdo4nP4OIa6osQuus7s',
    appId: '1:250945452144:ios:62e40e11b1dfcefd98dcb5',
    messagingSenderId: '250945452144',
    projectId: 'memoraapp-c5a0a',
    storageBucket: 'memoraapp-c5a0a.firebasestorage.app',
    iosBundleId: 'com.example.memoraApplication',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyBJxq-z0d0PgbGzrdo4nP4OIa6osQuus7s',
    appId: '1:250945452144:ios:62e40e11b1dfcefd98dcb5',
    messagingSenderId: '250945452144',
    projectId: 'memoraapp-c5a0a',
    storageBucket: 'memoraapp-c5a0a.firebasestorage.app',
    iosBundleId: 'com.example.memoraApplication',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyBB7AOt_tblA7kuL4lyaWP_eJJFy7ps24U',
    appId: '1:250945452144:web:7f000bc82522884198dcb5',
    messagingSenderId: '250945452144',
    projectId: 'memoraapp-c5a0a',
    authDomain: 'memoraapp-c5a0a.firebaseapp.com',
    storageBucket: 'memoraapp-c5a0a.firebasestorage.app',
    measurementId: 'G-83DNGW4LKD',
  );
}


==================== FILE: lib\main.dart ====================
// lib/main.dart

import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_messaging/firebase_messaging.dart';

import 'firebase_options.dart';
import 'screens/splash_screen.dart';
import 'screens/incoming_call_screen.dart';
import 'services/notification_service.dart';

/// Global navigator key so NotificationService can navigate from
/// notification taps (e.g., to an incoming-call screen).
final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Register background handler BEFORE Firebase.initializeApp().
  FirebaseMessaging.onBackgroundMessage(
    NotificationService.firebaseMessagingBackgroundHandler,
  );

  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );

  // Initialize local notifications + FCM listeners.
  await NotificationService.initialize();

  runApp(const MemoraApp());
}

class MemoraApp extends StatelessWidget {
  const MemoraApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      navigatorKey: navigatorKey,
      title: 'Memora',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        visualDensity: VisualDensity.adaptivePlatformDensity,
      ),
      // Your original entry flow
      home: const SplashScreen(),

      // Route for the incoming call screen
      routes: {
        IncomingCallScreen.routeName: (context) {
          final args = ModalRoute.of(context)!.settings.arguments
              as Map<String, dynamic>?;

          final callerName = args?['callerName'] as String? ?? 'Unknown';
          final callId = args?['callId'] as String? ?? '';

          return IncomingCallScreen(
            callerName: callerName,
            callId: callId,
          );
        },
      },
    );
  }
}


==================== FILE: lib\models\user_profile.dart ====================

class UserProfile {
  final String name;
  final String gender;
  final String phone;
  final String language;
  final String status;

  UserProfile({
    required this.name,
    required this.gender,
    required this.phone,
    required this.language,
    this.status = 'new',
  });

  factory UserProfile.fromJson(Map<String, dynamic> json) => UserProfile(
        name: json['name'],
        gender: json['gender'],
        phone: json['user_phone'],
        language: json['language'],
        status: json['status'] ?? 'new',
      );

  Map<String, dynamic> toJson() => {
        'name': name,
        'gender': gender,
        'user_phone': phone,
        'language': language,
        'status': status,
      };

  UserProfile copyWith({String? status}) {
    return UserProfile(
      name: name,
      gender: gender,
      phone: phone,
      language: language,
      status: status ?? this.status,
    );
  }
}


==================== FILE: lib\screens\incoming_call_screen.dart ====================
// lib/screens/incoming_call_screen.dart

import 'package:flutter/material.dart';
import '../models/user_profile.dart';
import '../services/api_service.dart';
import '../services/user_profile_service.dart';

import '../services/notification_service.dart';
import 'main_conversation_screen.dart';

class IncomingCallScreen extends StatefulWidget {
  static const String routeName = '/incoming_call';

  final String callerName;
  final String callId;

  const IncomingCallScreen({
    super.key,
    required this.callerName,
    required this.callId,
  });

  @override
  State<IncomingCallScreen> createState() => _IncomingCallScreenState();
}

class _IncomingCallScreenState extends State<IncomingCallScreen> {
  bool _isProcessing = false;

  // Helper to get the current user's phone number
  Future<String?> _getUserPhone() async {
    final profile = await UserProfileService.loadProfile();
    return profile?.phone;
  }

  Future<void> _declineCall() async {
    if (_isProcessing) return;
    setState(() => _isProcessing = true);

    try {
      // Notify the backend that the call was declined.
      final userPhone = await _getUserPhone();
      if (userPhone != null) {
        // We don't wait for this to finish, just fire and forget.
        ApiService().declineCall(userPhone, widget.callId);
      }
      await NotificationService.cancelIncomingCallNotification();
    } finally {
      // Always close the screen after declining.
      if (mounted) {
        setState(() => _isProcessing = false);
        Navigator.of(context).pop();
      }
    }
  }

  Future<void> _answerCall() async {
    if (_isProcessing) return;
    setState(() => _isProcessing = true);

    try {
      // Notify the backend that the call was accepted.
      final userPhone = await _getUserPhone();
      if (userPhone == null) {
        // Can't answer without a user profile, so just close the screen.
        if (mounted) Navigator.of(context).pop();
        return;
      }

      final response = await ApiService().answerCall(userPhone, widget.callId);
      await NotificationService.cancelIncomingCallNotification();

      // Navigate to the main conversation screen with the initial message from the backend.
      if (mounted) {
        Navigator.of(context).pushReplacement(
          MaterialPageRoute(
            builder: (_) => MainConversationScreen(
              userPhone: userPhone,
              // Use the message from the answer-call response.
              initialMessage:
                  response['initial_message'] ?? 'Hello, how can I help?',
            ),
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isProcessing = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Scaffold(
      backgroundColor: Colors.black,
      body: SafeArea(
        child: Column(
          children: [
            const SizedBox(height: 32),
            Text(
              'Incoming call',
              style: theme.textTheme.titleMedium?.copyWith(
                color: Colors.white70,
              ),
            ),
            const SizedBox(height: 16),
            Text(
              widget.callerName,
              textAlign: TextAlign.center,
              style: theme.textTheme.headlineMedium?.copyWith(
                color: Colors.white,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              'Memora',
              style: theme.textTheme.bodyMedium?.copyWith(
                color: Colors.white54,
              ),
            ),
            const Spacer(),
            if (_isProcessing)
              const Padding(
                padding: EdgeInsets.only(bottom: 24),
                child: CircularProgressIndicator(
                  valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                ),
              ),
            Padding(
              padding: const EdgeInsets.only(bottom: 40.0),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                children: [
                  _buildActionButton(
                    label: 'Decline',
                    icon: Icons.call_end,
                    color: Colors.red,
                    onPressed: _declineCall,
                  ),
                  _buildActionButton(
                    label: 'Answer',
                    icon: Icons.call,
                    color: Colors.green,
                    onPressed: _answerCall,
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildActionButton({
    required String label,
    required IconData icon,
    required Color color,
    required VoidCallback onPressed,
  }) {
    return Column(
      children: [
        FloatingActionButton(
          heroTag: label,
          onPressed: onPressed,
          backgroundColor: color,
          child: Icon(icon, color: Colors.white),
        ),
        const SizedBox(height: 8),
        Text(
          label,
          style: const TextStyle(
            color: Colors.white,
          ),
        ),
      ],
    );
  }
}


==================== FILE: lib\screens\main_conversation_screen.dart ====================
// lib/screens/main_conversation_screen.dart

import 'package:flutter/material.dart';
import 'package:permission_handler/permission_handler.dart'; // Import permission_handler
import 'package:flutter/services.dart'; // Required for closing the app
// --- FIX APPLIED HERE: Added a line break to correctly import the ApiService ---
import 'splash_screen.dart';
import '../services/api_service.dart';

class MainConversationScreen extends StatefulWidget {
  final String initialMessage;
  final String userPhone;

  const MainConversationScreen({
    super.key,
    required this.userPhone,
    required this.initialMessage,
  });

  @override
  State<MainConversationScreen> createState() => _MainConversationScreenState();
}

class _MainConversationScreenState extends State<MainConversationScreen> {
  final TextEditingController _messageController = TextEditingController();
  final ApiService _apiService = ApiService();
  final List<Map<String, String>> _messages = [];
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    // --- NEW: Log to confirm this screen was created ---
    print("[Flow] MainConversationScreen initState called.");

    // --- NEW: Check for the overlay permission here ---
    _checkAndRequestOverlayPermission();

    if (widget.initialMessage.isNotEmpty) {
      _addMessage('assistant', widget.initialMessage);
    }
  }

  // --- NEW: Function to handle the overlay permission ---
  Future<void> _checkAndRequestOverlayPermission() async {
    print("[Permission] Checking System Alert Window permission...");
    final status = await Permission.systemAlertWindow.status;
    print("[Permission] Current System Alert Window status: $status");

    if (status.isGranted) {
      print("[Permission] System Alert Window permission is granted.");
      return;
    }

    // If not granted, request it. This will open the app settings screen for the user.
    print(
        "[Permission] System Alert Window permission not granted. Requesting...");
    // We don't await this to avoid blocking the UI, but it will open settings.
    await Permission.systemAlertWindow.request();
  }

  void _addMessage(String sender, String text) {
    setState(() {
      _messages.insert(0, {'sender': sender, 'text': text});
    });
  }

  Future<void> _sendMessage() async {
    if (_messageController.text.isEmpty || _isLoading) {
      return;
    }

    final String messageText = _messageController.text;
    _addMessage('user', messageText);
    _messageController.clear();

    setState(() {
      _isLoading = true;
    });

    try {
      final String reply =
          await _apiService.sendMessage(widget.userPhone, messageText);
      _addMessage('assistant', reply);
    } catch (e) {
      _addMessage('assistant', 'Sorry, I ran into an error. Please try again.');
      print('Error sending message: $e');
    } finally {
      setState(() {
        _isLoading = false;
      });
    }
  }

  // --- HANG UP BUTTON FUNCTIONALITY - UPDATED ---
  Future<void> _hangUp() async {
    // 1. First, inform the backend that the user is disconnecting.
    // We use widget.userPhone to identify the user.
    await _apiService.disconnect(widget.userPhone);

    // --- FIX: Use a MethodChannel to reliably move the app to the background ---
    // This is more compatible than SystemNavigator.sendToBackground().
    const platform = MethodChannel('com.example.memora_application/native');
    await platform.invokeMethod('sendToBackground');
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        backgroundColor: Colors.blue,
        title: const Text('Memora', style: TextStyle(color: Colors.white)),
        iconTheme: const IconThemeData(color: Colors.white),
        actionsIconTheme: const IconThemeData(color: Colors.white),
        actions: [
          IconButton(
            icon: const Icon(Icons.call_end, color: Colors.redAccent, size: 28),
            onPressed: _hangUp,
            tooltip: 'Close App',
          ),
          const SizedBox(width: 8),
        ],
      ),
      body: SafeArea(
        child: Column(
          children: [
            Expanded(
              child: ListView.builder(
                reverse: true,
                padding: const EdgeInsets.all(8.0),
                itemCount: _messages.length,
                itemBuilder: (context, index) {
                  final message = _messages[index];
                  final isUser = message['sender'] == 'user';
                  return Align(
                    alignment:
                        isUser ? Alignment.centerRight : Alignment.centerLeft,
                    child: Container(
                      margin: const EdgeInsets.symmetric(
                          vertical: 5, horizontal: 10),
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        color: isUser ? Colors.blue[100] : Colors.grey[200],
                        borderRadius: BorderRadius.circular(15),
                      ),
                      child: Text(message['text']!),
                    ),
                  );
                },
              ),
            ),
            if (_isLoading) const LinearProgressIndicator(),
            _buildTextComposer(),
          ],
        ),
      ),
    );
  }

  Widget _buildTextComposer() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 8.0),
      child: Row(
        children: [
          Expanded(
            child: TextField(
              controller: _messageController,
              decoration: InputDecoration(
                hintText: 'Type your message...',
                filled: true,
                fillColor: Colors.grey[100],
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(20),
                  borderSide: BorderSide.none,
                ),
              ),
              onSubmitted: (_) => _sendMessage(),
            ),
          ),
          const SizedBox(width: 8),
          IconButton(
            icon: const Icon(Icons.send, color: Colors.blue),
            onPressed: _sendMessage,
          ),
        ],
      ),
    );
  }
}


==================== FILE: lib\screens\registration_screen.dart ====================
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:permission_handler/permission_handler.dart';
import '../models/user_profile.dart';
import '../services/api_service.dart';
import 'main_conversation_screen.dart';
import '../services/user_profile_service.dart';

class RegistrationScreen extends StatefulWidget {
  @override
  _RegistrationScreenState createState() => _RegistrationScreenState();
}

class _RegistrationScreenState extends State<RegistrationScreen> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _phoneController = TextEditingController();
  String _selectedGender = 'male';
  String _selectedLanguage = 'en';

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Registration')),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: SingleChildScrollView(
          child: Form(
            key: _formKey,
            child: Column(
              children: <Widget>[
                TextFormField(
                  controller: _nameController,
                  decoration: InputDecoration(labelText: 'Full Name'),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter your name';
                    }
                    return null;
                  },
                ),
                TextFormField(
                  controller: _phoneController,
                  decoration: InputDecoration(labelText: 'Phone Number'),
                  keyboardType: TextInputType.phone,
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter your phone number';
                    }
                    return null;
                  },
                ),
                DropdownButtonFormField<String>(
                  value: _selectedGender,
                  decoration: InputDecoration(labelText: 'Gender'),
                  items: ['male', 'female', 'other'].map((String value) {
                    return DropdownMenuItem<String>(
                      value: value,
                      child: Text(value),
                    );
                  }).toList(),
                  onChanged: (newValue) {
                    setState(() {
                      _selectedGender = newValue!;
                    });
                  },
                ),
                DropdownButtonFormField<String>(
                  value: _selectedLanguage,
                  decoration: InputDecoration(labelText: 'Language'),
                  items: ['en', 'he'].map((String value) {
                    return DropdownMenuItem<String>(
                      value: value,
                      child: Text(value),
                    );
                  }).toList(),
                  onChanged: (newValue) {
                    setState(() {
                      _selectedLanguage = newValue!;
                    });
                  },
                ),
                SizedBox(height: 20),
                ElevatedButton(
                  onPressed: _register,
                  child: Text('Register'),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  void _register() async {
    print("[Flow] RegistrationScreen: 'Register' pressed.");
    if (_formKey.currentState!.validate()) {
      // Get FCM token
      String? fcmToken = await FirebaseMessaging.instance.getToken();
      if (fcmToken == null) {
        print('Failed to get FCM token');
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content:
                  Text('Could not get notification token. Please try again.')),
        );
        return;
      }

      print(
          "[Flow] RegistrationScreen: Got FCM Token. Preparing user profile...");
      // Normalize phone number
      String normalizedPhone = '972' + _phoneController.text.substring(1);

      // Create user profile with 'registering' status
      UserProfile userProfile = UserProfile(
        name: _nameController.text,
        gender: _selectedGender,
        phone: normalizedPhone,
        language: _selectedLanguage,
        status: 'registering',
      );
      print(
          "[Flow] RegistrationScreen: Saving 'registering' profile locally...");
      await UserProfileService.saveProfile(userProfile);

      // Log the data being sent
      final userData = {
        ...userProfile.toJson(),
        'fcm_token': fcmToken,
      };
      print('Attempting to register user with data: ${jsonEncode(userData)}');

      try {
        print("[Flow] RegistrationScreen: Calling backend registerUser API...");
        final registrationData =
            await ApiService().registerUser(userProfile, fcmToken);

        // Update profile to 'active'
        final activeProfile = userProfile.copyWith(status: 'active');
        print(
            "[Flow] RegistrationScreen: Backend registration successful. Saving 'active' profile locally...");
        await UserProfileService.saveProfile(activeProfile);

        print('Registration successful!');

        final String initialMessage = registrationData['initial_message'] ??
            "Welcome! How can I help you?";

        print('[Flow] Preparing to navigate to MainConversationScreen...');
        // Use `mounted` check to ensure the widget is still in the tree before navigating.
        if (!mounted) return;

        Navigator.pushReplacement(
          context,
          MaterialPageRoute(
              builder: (context) => MainConversationScreen(
                  userPhone: normalizedPhone, initialMessage: initialMessage)),
        );
        print('[Flow] Navigation command sent.');
      } catch (e) {
        print('Registration failed with error: $e');
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Registration failed: $e')),
        );
      }
    }
  }
}


==================== FILE: lib\screens\splash_screen.dart ====================
// lib/screens/splash_screen.dart

import 'package:flutter/material.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:permission_handler/permission_handler.dart';
import '../models/user_profile.dart';
import '../services/user_profile_service.dart';
import '../services/api_service.dart';
import 'main_conversation_screen.dart';
import 'welcome_screen.dart';

class SplashScreen extends StatefulWidget {
  const SplashScreen({super.key});

  @override
  State<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends State<SplashScreen> {
  @override
  void initState() {
    super.initState();
    print("[Flow] SplashScreen.initState(): Starting.");
    _determineInitialRoute();
  }

  /// A generic function to check and print the status of all relevant permissions.
  Future<void> _checkAllPermissions() async {
    print("--- [Generic Permission Check] Starting ---");

    final permissions = [
      Permission.microphone,
      Permission.notification,
      Permission.location,
      Permission.systemAlertWindow, // "Display over other apps"
    ];

    for (var permission in permissions) {
      final status = await permission.status;
      // The permission name is long, so we split it to get the last part.
      print(
          "[Generic Permission Check] ${permission.toString().split('.').last}: $status");
    }
    print("--- [Generic Permission Check] Finished ---");
  }

  Future<void> _determineInitialRoute() async {
    print("[Flow] SplashScreen: Determining initial route...");
    // Give the splash screen a moment to be visible
    await Future.delayed(const Duration(seconds: 1));

    print("[Flow] SplashScreen: Loading user profile...");
    final userProfile = await UserProfileService.loadProfile();

    // Run our generic permission check for debugging purposes.
    await _checkAllPermissions();

    // If no profile exists or status is not 'active', go to registration flow.
    if (userProfile == null || userProfile.status != 'active') {
      print(
          "[Flow] SplashScreen: No active profile found. Navigating to WelcomeScreen.");
      if (mounted) {
        Navigator.of(context).pushReplacement(
            MaterialPageRoute(builder: (_) => const WelcomeScreen()));
      }
      return;
    }

    print(
        "[Flow] SplashScreen: Active profile found. Verifying user with backend...");
    // If profile exists, verify the user and go to the main screen.
    try {
      final fcmToken = await FirebaseMessaging.instance.getToken();
      final verificationData =
          await ApiService().verifyUser(userProfile, fcmToken!);
      if (mounted) {
        print(
            "[Flow] SplashScreen: User verified. Navigating to MainConversationScreen.");
        Navigator.of(context).pushReplacement(MaterialPageRoute(
            builder: (_) => MainConversationScreen(
                userPhone: userProfile.phone,
                initialMessage:
                    verificationData['message'] ?? 'Welcome back!')));
      }
    } catch (e) {
      // If verification fails, delete the stale profile and go to registration.
      print(
          "[Flow] SplashScreen: User verification failed ($e). Deleting stale profile and navigating to WelcomeScreen.");
      await UserProfileService.deleteProfile();
      if (mounted) {
        Navigator.of(context).pushReplacement(
            MaterialPageRoute(builder: (_) => const WelcomeScreen()));
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return const Scaffold(
      body: Center(
        child: CircularProgressIndicator(),
      ),
    );
  }
}


==================== FILE: lib\screens\welcome_screen.dart ====================
// lib/screens/welcome_screen.dart

import 'package:flutter/material.dart';
import 'registration_screen.dart';
import 'package:permission_handler/permission_handler.dart';

class WelcomeScreen extends StatelessWidget {
  const WelcomeScreen({super.key});

  // This is your existing function to handle permissions and navigation.
  Future<void> _continue(BuildContext context) async {
    print(
        "[Flow] WelcomeScreen: 'Continue' pressed. Requesting standard permissions...");
    // Request all necessary permissions at once.
    await [
      Permission.notification,
      Permission.microphone,
      Permission.location,
    ].request();
    print(
        "[Flow] WelcomeScreen: Standard permissions requested. Navigating to RegistrationScreen.");

    // Navigate to the RegistrationScreen.
    // We use pushReplacement to prevent the user from navigating back to the welcome screen.
    Navigator.pushReplacement(
      context,
      // --- FIX #1: Removed the 'const' keyword ---
      // RegistrationScreen is a StatefulWidget and does not have a const constructor.
      MaterialPageRoute(builder: (_) => RegistrationScreen()),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(20),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              const SizedBox(height: 40),

              // Your logo from the assets folder.
              Image.asset('assets/images/logo.png', height: 150, width: 150),

              const SizedBox(height: 20),

              const Text(
                "×§Ö·×‘Ö¼Ö¸×œÖ·×ª ×¤Ö¼Ö¸× Ö´×™×!", // "Welcome!" in Hebrew
                style: TextStyle(
                    fontSize: 32,
                    fontWeight: FontWeight.bold,
                    color: Colors.black),
              ),

              const SizedBox(height: 10),

              const Text(
                "× ×“×¨×™×š ××•×ª×š ×¦×¢×“ ××—×¨ ×¦×¢×“.", // "We will guide you step by step."
                style: TextStyle(fontSize: 18, color: Colors.black87),
              ),

              const SizedBox(height: 40),

              const Text(
                "×›×“×™ ×œ×”×©×ª×ž×© ×‘×¢×•×–×¨, ×× ×• ×–×§×•×§×™× ×œ×’×™×©×” ×œ:", // "To use the assistant, we need access to:"
                style: TextStyle(fontSize: 18, color: Colors.black),
                textAlign: TextAlign.center,
              ),

              const SizedBox(height: 20),

              // Re-using your infoRow helper widget.
              infoRow(Icons.mic,
                  "×ž×™×§×¨×•×¤×•×Ÿ ×œ×¤×§×•×“×•×ª ×§×•×œ×™×•×ª"), // "Microphone for voice commands"
              infoRow(Icons.location_on,
                  "×ž×™×§×•× ×œ×©×™×¨×•×ª×™× ×©×™×ž×•×©×™×™×"), // "Location for useful services"
              infoRow(Icons.notifications,
                  "×”×ª×¨××•×ª ×©×™×¡×™×™×¢×• ×œ×š"), // "Notifications to help you"

              const Spacer(), // This pushes the button to the bottom.

              SizedBox(
                width: double.infinity,
                height: 55,
                child: ElevatedButton(
                  onPressed: () => _continue(context),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.blue,
                    // --- FIX #2: Corrected the typo in the class name ---
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(10),
                    ),
                  ),
                  child: const Text(
                    "×œÖ°×”Ö·×ž×©×Ö´×™×š", // "Continue"
                    style: TextStyle(
                        fontSize: 22,
                        color: Colors.white,
                        fontWeight: FontWeight.bold),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  // Helper widget for displaying permission information rows.
  Widget infoRow(IconData icon, String text) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(icon, color: Colors.blue, size: 28),
          const SizedBox(width: 15),
          // Use Expanded to make sure text wraps gracefully on smaller screens.
          Expanded(
            child: Text(
              text,
              style: const TextStyle(fontSize: 16, color: Colors.black54),
              textAlign: TextAlign.start,
            ),
          ),
        ],
      ),
    );
  }
}


==================== FILE: lib\services\api_service.dart ====================
// lib/services/api_service.dart

import 'dart:convert';
import 'dart:async';
import 'package:http/http.dart' as http;
import '../models/user_profile.dart';

class ApiService {
  // === CONFIGURATION ===
  static const String _baseUrl = 'http://memora.aigents.co.il';
  static const Duration _timeoutDuration = Duration(seconds: 20);

  // === PRIVATE HELPER METHOD ===
  static http.Response _handleResponse(http.Response response) {
    if (response.statusCode >= 200 && response.statusCode < 300) {
      return response;
    } else {
      throw Exception(
        'API Error: Status ${response.statusCode}, Body: ${response.body}',
      );
    }
  }

  // === PUBLIC API METHODS ===

  Future<Map<String, dynamic>> registerUser(
      UserProfile profile, String fcmToken) async {
    final url = Uri.parse('$_baseUrl/register-user');
    final requestBody = profile.toJson();
    requestBody['fcm_token'] = fcmToken;
    if (requestBody.containsKey('phone')) {
      requestBody['user_phone'] = requestBody['phone'];
      requestBody.remove('phone');
    }

    print('Sending POST request to: $url');
    print('With body: ${json.encode(requestBody)}');

    try {
      final response = await http
          .post(
            url,
            headers: {'Content-Type': 'application/json; charset=UTF-8'},
            body: json.encode(requestBody),
          )
          .timeout(_timeoutDuration);

      final handledResponse = _handleResponse(response);
      return json.decode(utf8.decode(handledResponse.bodyBytes));
    } catch (e) {
      print('Error during user registration: $e');
      rethrow;
    }
  }

  Future<Map<String, dynamic>> verifyUser(
      UserProfile profile, String fcmToken) async {
    final url = Uri.parse('$_baseUrl/initiate-session');
    final requestBody = profile.toJson();
    requestBody['fcm_token'] = fcmToken;
    if (requestBody.containsKey('phone')) {
      requestBody['user_phone'] = requestBody['phone'];
      requestBody.remove('phone');
    }

    print('Sending POST request to: $url');
    print('With body: ${json.encode(requestBody)}');

    try {
      final response = await http
          .post(
            url,
            headers: {'Content-Type': 'application/json; charset=UTF-8'},
            body: json.encode(requestBody),
          )
          .timeout(_timeoutDuration);

      final handledResponse = _handleResponse(response);
      return json.decode(utf8.decode(handledResponse.bodyBytes));
    } catch (e) {
      print('Error during user verification: $e');
      rethrow;
    }
  }

  Future<String> sendMessage(String userPhone, String message) async {
    final url = Uri.parse('$_baseUrl/voice/process');
    print('Sending POST request to: $url');
    // --- NEW: Log the content of the message being sent ---
    print('Sending message content: $message');

    try {
      final response = await http
          .post(
            url,
            headers: {'Content-Type': 'application/json; charset=UTF-8'},
            body: json.encode({
              'user_id': userPhone,
              'message': message,
              'audio_data': null,
            }),
          )
          .timeout(_timeoutDuration);

      final handledResponse = _handleResponse(response);
      String reply = utf8.decode(handledResponse.bodyBytes);

      // --- NEW: Log the content of the reply received from the backend ---
      print('Received reply content: $reply');

      if (reply.startsWith('"') && reply.endsWith('"')) {
        reply = reply.substring(1, reply.length - 1);
      }

      if (reply.isNotEmpty) {
        return reply;
      } else {
        throw Exception(
            'API Error: Received an empty response from /voice/process.');
      }
    } catch (e) {
      print('Error sending message: $e');
      rethrow;
    }
  }

  // --- NEW DISCONNECT METHOD ---
  Future<void> disconnect(String userPhone) async {
    final url = Uri.parse('$_baseUrl/disconnect');
    print('Sending POST request to: $url');

    try {
      // We don't need to wait long for this. If it fails, the app still closes.
      await http
          .post(
            url,
            headers: {'Content-Type': 'application/json; charset=UTF-8'},
            body: json.encode({'user_phone': userPhone}),
          )
          .timeout(const Duration(seconds: 5));

      print('Disconnect message sent successfully for $userPhone.');
    } catch (e) {
      // We log the error but don't rethrow it, so the app can still close
      // even if the disconnect message fails to send (e.g., no network).
      print('Could not send disconnect message: $e');
    }
  }

  // --- NEW METHOD 1: answerCall ---
  /// Informs the backend that the user has answered a proactive "call".
  Future<Map<String, dynamic>> answerCall(
      String userPhone, String callId) async {
    final url = Uri.parse('$_baseUrl/answer-call');
    final body = {'user_phone': userPhone, 'call_id': callId};
    print('Sending POST request to: $url with body: ${json.encode(body)}');

    try {
      final response = await http
          .post(
            url,
            headers: {'Content-Type': 'application/json; charset=UTF-8'},
            body: json.encode(body),
          )
          .timeout(const Duration(seconds: 10));

      final handledResponse = _handleResponse(response);
      print('Successfully sent answer-call.');
      // Decode and return the JSON body from the response.
      return json.decode(utf8.decode(handledResponse.bodyBytes));
    } catch (e) {
      print('Failed to send answer-call: $e');
      rethrow; // Rethrow to let the UI know the call failed
    }
  }

  // --- NEW METHOD 2: declineCall ---
  /// Informs the backend that the user has declined a proactive "call".
  Future<void> declineCall(String userPhone, String callId) async {
    final url = Uri.parse('$_baseUrl/decline-call');
    final body = {'user_phone': userPhone, 'call_id': callId};
    print('Sending POST request to: $url with body: ${json.encode(body)}');

    try {
      await http
          .post(
            url,
            headers: {'Content-Type': 'application/json; charset=UTF-8'},
            body: json.encode(body),
          )
          .timeout(const Duration(seconds: 10));

      print('Successfully sent decline-call.');
    } catch (e) {
      // We don't rethrow here, as the UI should close even if the decline message fails.
      print('Failed to send decline-call: $e');
    }
  }
}


==================== FILE: lib\services\notification_service.dart ====================
// lib/services/notification_service.dart

import 'dart:convert';

import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';

import '../main.dart'; // for navigatorKey
import '../screens/incoming_call_screen.dart';

class NotificationService {
  NotificationService._(); // private constructor

  static final FlutterLocalNotificationsPlugin _plugin =
      FlutterLocalNotificationsPlugin();

  /// Call once from main() in the foreground isolate.
  static Future<void> initialize() async {
    // --- Local notifications initialization ---
    const androidInit = AndroidInitializationSettings('@mipmap/ic_launcher');
    const initSettings = InitializationSettings(
      android: androidInit,
    );

    await _plugin.initialize(
      initSettings,
      onDidReceiveNotificationResponse: _onNotificationResponse,
    );

    // --- FCM foreground & tap handlers ---
    FirebaseMessaging.onMessage.listen(_onForegroundMessage);
    FirebaseMessaging.onMessageOpenedApp.listen(_onMessageOpenedApp);

    // If the app was launched by tapping a notification
    final initialMessage = await FirebaseMessaging.instance.getInitialMessage();
    if (initialMessage != null) {
      _handleRemoteMessage(initialMessage, source: 'launch');
    }
  }

  // ============================================================
  // FCM BACKGROUND HANDLER
  // ============================================================
  /// Registered in main.dart as:
  /// FirebaseMessaging.onBackgroundMessage(NotificationService.firebaseMessagingBackgroundHandler);
  @pragma('vm:entry-point')
  static Future<void> firebaseMessagingBackgroundHandler(
    RemoteMessage message,
  ) async {
    // Ensure Firebase is ready in the background isolate.
    await Firebase.initializeApp();

    // Initialize local notifications (no tap callback needed here).
    const androidInit = AndroidInitializationSettings('@mipmap/ic_launcher');
    const initSettings = InitializationSettings(android: androidInit);
    await _plugin.initialize(initSettings);

    _handleRemoteMessage(message, source: 'background');
  }

  // ============================================================
  // FCM MESSAGE ROUTING
  // ============================================================
  static void _onForegroundMessage(RemoteMessage message) {
    _handleRemoteMessage(message, source: 'foreground');
  }

  static void _onMessageOpenedApp(RemoteMessage message) {
    _handleRemoteMessage(message, source: 'opened_app');
  }

  /// Central place to interpret incoming FCM messages.
  static void _handleRemoteMessage(
    RemoteMessage message, {
    required String source,
  }) {
    final data = message.data;
    final type = data['type'];

    if (type == 'incoming_call') {
      final callerName = data['callerName'] ?? 'Unknown';
      final callId = data['callId'] ?? '';

      _showIncomingCallNotification(
        callerName: callerName,
        callId: callId,
      );
    } else {
      // Default/basic notification
      final title = data['title'] ?? 'Memora';
      final body = data['body'] ?? 'You have a new notification';

      _showBasicNotification(title: title, body: body);
    }
  }

  // ============================================================
  // LOCAL NOTIFICATION HELPERS
  // ============================================================

  /// Simple notification (no full-screen).
  static Future<void> _showBasicNotification({
    required String title,
    required String body,
  }) async {
    const androidDetails = AndroidNotificationDetails(
      'memora_basic_channel',
      'Memora Notifications',
      channelDescription: 'General Memora notifications',
      importance: Importance.defaultImportance,
      priority: Priority.defaultPriority,
    );

    const details = NotificationDetails(android: androidDetails);

    await _plugin.show(
      DateTime.now().millisecondsSinceEpoch ~/ 1000, // unique ID
      title,
      body,
      details,
    );
  }

  /// Full-screen incoming call notification.
  static Future<void> _showIncomingCallNotification({
    required String callerName,
    required String callId,
  }) async {
    const androidDetails = AndroidNotificationDetails(
      'memora_incoming_call_channel',
      'Incoming Calls',
      channelDescription: 'Memora incoming call notifications',
      importance: Importance.max,
      priority: Priority.high,
      category: AndroidNotificationCategory.call,
      fullScreenIntent: true, // ðŸ’¥ key flag to get call-style behavior
      autoCancel: false,
      ongoing: true,
    );

    const details = NotificationDetails(android: androidDetails);

    final payload = jsonEncode({
      'type': 'incoming_call',
      'callerName': callerName,
      'callId': callId,
    });

    await _plugin.show(
      9999, // fixed ID for the active call
      'Incoming call',
      callerName,
      details,
      payload: payload,
    );
  }

  /// Cancel the active incoming call notification.
  static Future<void> cancelIncomingCallNotification() async {
    await _plugin.cancel(9999);
  }

  // ============================================================
  // TAP HANDLER
  // ============================================================

  static void _onNotificationResponse(NotificationResponse response) {
    final payload = response.payload;
    if (payload == null || payload.isEmpty) return;

    final data = jsonDecode(payload) as Map<String, dynamic>;
    final type = data['type'];

    if (type == 'incoming_call') {
      final callerName = data['callerName'] as String? ?? 'Unknown';
      final callId = data['callId'] as String? ?? '';

      // Navigate to the incoming call screen
      navigatorKey.currentState?.pushNamed(
        IncomingCallScreen.routeName,
        arguments: {
          'callerName': callerName,
          'callId': callId,
        },
      );
    }
  }
}


==================== FILE: lib\services\user_profile_service.dart ====================

import 'dart:convert';
import '../models/user_profile.dart';
import 'package:shared_preferences/shared_preferences.dart';

class UserProfileService {
  static const _key = 'user_profile';

  static Future<void> saveProfile(UserProfile profile) async {
    final prefs = await SharedPreferences.getInstance();
    final jsonString = jsonEncode(profile.toJson());
    await prefs.setString(_key, jsonString);
  }

  static Future<UserProfile?> loadProfile() async {
    final prefs = await SharedPreferences.getInstance();
    final jsonString = prefs.getString(_key);
    if (jsonString != null) {
      return UserProfile.fromJson(jsonDecode(jsonString));
    }
    return null;
  }

  static Future<void> deleteProfile() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_key);
  }
}


==================== FILE: lib\utils\constants.dart ====================

const String BASE_URL = 'http://memora.aigents.co.il';


==================== FILE: android\build.gradle.kts ====================
allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

val newBuildDir: Directory = rootProject.layout.buildDirectory.dir("../../build").get()
rootProject.layout.buildDirectory.value(newBuildDir)

subprojects {
    val newSubprojectBuildDir: Directory = newBuildDir.dir(project.name)
    project.layout.buildDirectory.value(newSubprojectBuildDir)
}
subprojects {
    project.evaluationDependsOn(":app")
}

tasks.register<Delete>("clean") {
    delete(rootProject.layout.buildDirectory)
}


==================== FILE: android\settings.gradle.kts ====================
pluginManagement {
    val flutterSdkPath = run {
        val properties = java.util.Properties()
        file("local.properties").inputStream().use { properties.load(it) }
        val flutterSdkPath = properties.getProperty("flutter.sdk")
        require(flutterSdkPath != null) { "flutter.sdk not set in local.properties" }
        flutterSdkPath
    }

    includeBuild("$flutterSdkPath/packages/flutter_tools/gradle")

    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

plugins {
    id("dev.flutter.flutter-plugin-loader") version "1.0.0"
    id("com.android.application") version "8.7.3" apply false
    id("org.jetbrains.kotlin.android") version "2.1.0" apply false
}

include(":app")


==================== FILE: android\app\build.gradle.kts ====================
plugins {
    id("com.android.application")
    id("kotlin-android")
    // The Flutter Gradle Plugin must be applied after the Android and Kotlin Gradle plugins.
    id("dev.flutter.flutter-gradle-plugin")
}

android {
    namespace = "com.example.memora_application"
    compileSdk = 35
    ndkVersion = flutter.ndkVersion

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
        // Required for flutter_local_notifications
        isCoreLibraryDesugaringEnabled = true
    }

    kotlinOptions {
        jvmTarget = "17"
    }

        defaultConfig {
            // TODO: Specify your own unique Application ID (https://developer.android.com/studio/build/application-id.html).
            applicationId = "com.example.memora_application"
            // You can update the following values to match your application needs.
            // For more information, see: https://flutter.dev/to/review-gradle-config.
            minSdk = 23
            targetSdk = flutter.targetSdkVersion
            versionCode = flutter.versionCode
            versionName = flutter.versionName
            ndkVersion = "27.0.12077973" // Add this line
        }

        buildTypes {
            release {
                // TODO: Add your own signing config for the release build.
                // Signing with the debug keys for now, so `flutter run --release` works.
                signingConfig = signingConfigs.getByName("debug")
            }
        }
}

dependencies {
    // Required for flutter_local_notifications
    coreLibraryDesugaring("com.android.tools:desugar_jdk_libs:2.0.4")
}

flutter {
    source = "../.."
}


==================== FILE: android\app\src\debug\AndroidManifest.xml ====================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>


==================== FILE: android\app\src\main\AndroidManifest.xml ====================
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.memora_application">

    <!-- Required permissions for notifications and calls -->
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.RECORD_AUDIO" />
    <uses-permission android:name="android.permission.MODIFY_AUDIO_SETTINGS" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    
    <!-- Notification permissions -->
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
    <uses-permission android:name="android.permission.SCHEDULE_EXACT_ALARM" />
    
    <!-- Full-screen intent permission for incoming calls (Android 12+) -->
    <uses-permission android:name="android.permission.USE_FULL_SCREEN_INTENT" />

    <application
        android:label="Memora"
        android:icon="@mipmap/ic_launcher"
        android:requestLegacyExternalStorage="true">

        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:showWhenLocked="true"
            android:turnScreenOn="true"
            android:launchMode="singleTop"
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">

            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>

            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data android:name="io.flutter.embedding.android.NormalTheme" android:resource="@style/NormalTheme" />
        </activity>

        <!-- High-priority channel for incoming calls. This is crucial for full-screen intents. -->
        <meta-data
            android:name="com.google.firebase.messaging.default_notification_channel_id"
            android:value="memora_incoming_call_channel" />
        <service
            android:name=".MyFirebaseMessagingService"
            android:exported="false">
            <intent-filter>
                <action android:name="com.google.firebase.MESSAGING_EVENT"/>
            </intent-filter>
        </service>
        <!-- Notification channel definition -->
        <service
            android:name="com.google.firebase.messaging.FirebaseMessagingService"
            android:exported="false">
            <intent-filter>
                <action android:name="com.google.firebase.MESSAGING_EVENT" />
            </intent-filter>
        </service>

        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
</manifest>

<!-- The following file is not part of the project, but is needed for the fix -->
<!-- It should be created at android/app/src/main/kotlin/com/example/memora_application/MyFirebaseMessagingService.kt -->
<!--
package com.example.memora_application

import android.app.NotificationChannel
import android.app.NotificationManager
import android.os.Build
import com.google.firebase.messaging.FirebaseMessagingService

class MyFirebaseMessagingService : FirebaseMessagingService() {
    // This class is intentionally left empty.
    // Its purpose is to be declared in the AndroidManifest.xml, which triggers
    // the system to correctly process the notification channel metadata.
}
-->


==================== FILE: android\app\src\main\java\io\flutter\plugins\GeneratedPluginRegistrant.java ====================
package io.flutter.plugins;

import androidx.annotation.Keep;
import androidx.annotation.NonNull;
import io.flutter.Log;

import io.flutter.embedding.engine.FlutterEngine;

/**
 * Generated file. Do not edit.
 * This file is generated by the Flutter tool based on the
 * plugins that support the Android platform.
 */
@Keep
public final class GeneratedPluginRegistrant {
  private static final String TAG = "GeneratedPluginRegistrant";
  public static void registerWith(@NonNull FlutterEngine flutterEngine) {
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.core.FlutterFirebaseCorePlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin firebase_core, io.flutter.plugins.firebase.core.FlutterFirebaseCorePlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.messaging.FlutterFirebaseMessagingPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin firebase_messaging, io.flutter.plugins.firebase.messaging.FlutterFirebaseMessagingPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new com.dexterous.flutterlocalnotifications.FlutterLocalNotificationsPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin flutter_local_notifications, com.dexterous.flutterlocalnotifications.FlutterLocalNotificationsPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new com.baseflow.permissionhandler.PermissionHandlerPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin permission_handler_android, com.baseflow.permissionhandler.PermissionHandlerPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.sharedpreferences.SharedPreferencesPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin shared_preferences_android, io.flutter.plugins.sharedpreferences.SharedPreferencesPlugin", e);
    }
  }
}


==================== FILE: android\app\src\main\kotlin\com\example\memora_application\MainActivity.kt ====================
package com.example.memora_application

import io.flutter.embedding.android.FlutterActivity
import io.flutter.embedding.engine.FlutterEngine
import io.flutter.plugin.common.MethodChannel

class MainActivity: FlutterActivity() {
    // This channel name must match the one used in your Dart code.
    private val CHANNEL = "com.example.memora_application/native"

    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {
        super.configureFlutterEngine(flutterEngine)
        MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler {
            call, result ->
            if (call.method == "sendToBackground") {
                moveTaskToBack(true) // This is the native Android code to send the app to the background.
                result.success(null)
            } else {
                result.notImplemented()
            }
        }
    }
}

==================== FILE: android\app\src\main\res\drawable\launch_background.xml ====================
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>


==================== FILE: android\app\src\main\res\drawable-v21\launch_background.xml ====================
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>


==================== FILE: android\app\src\main\res\values\styles.xml ====================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>


==================== FILE: android\app\src\main\res\values-night\styles.xml ====================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>


==================== FILE: android\app\src\profile\AndroidManifest.xml ====================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>


==================== FILE: documents\mobile_protocol.txt ====================
Backend Integration Specification: MCI Voice Assistant (Multi-User Version)
1. System Overview

This document outlines the API and logic required for the backend agent system to integrate with the MCI Voice Assistant mobile app. The system now supports multiple, unique users, each identified by their phone number.

2. Core Concepts

user_phone / user_id: The primary and unique identifier for a user.
It is always provided in the normalized international format (e.g., 972547778005).

fcm_token: The unique registration token for the app on a specific device, provided by Firebase. This token is essential for sending push notifications and can change over time.

3. Database Requirements

The backend uses two main tables for user and device management.

**Table: `users`**
| Column     | Type        | Notes                                                        |
| :--------- | :---------- | :----------------------------------------------------------- |
| user_phone | VARCHAR(20) | Primary Key. The user's unique, normalized phone number.     |
| name       | VARCHAR(255)| The user's provided name.                                    |
| gender     | VARCHAR(10) | The user's gender ('male', 'female', or 'other').            |

**Table: `devices`**
| Column    | Type        | Notes                               |
| :-------- | :---------- | :---------------------------------- |
| `device_id` | `SERIAL`    | Primary Key.                        |
| `user_id` | `VARCHAR(20)` | Foreign Key to `users.user_phone`.  |
| `fcm_token` | `TEXT`      | Firebase Cloud Messaging token.     |

4. API Endpoints

The backend must expose the following HTTP POST endpoints. All request and response bodies are in JSON format.

Endpoint 1: First-Time User Registration

This endpoint is used by the mobile app ONLY when a user registers for the first time.

Method: POST
Path: /register-user
Request Body (JSON):
{
  "user_phone": "972541234567",
  "name": "×™×©×¨××œ ×™×©×¨××œ×™",
  "gender": "male",
  "language": "he", // Optional: "he" or "en". Defaults to "he" if not provided.
  "fcm_token": "dEgPUpGiSd64ytltFCdIWM:APA91b..."
}

Backend Logic:
- Receive the user data.
- Find or create a user in the `users` table based on `user_phone`.
- Create or update a corresponding record in the `devices` table, associating the `fcm_token` with the `user_phone`.
- This ensures that if a user registers on a new device, the new FCM token is captured without overwriting their core profile.

Success Response:
Status Code: 200 OK
Body (JSON): { "status": "success", "message": "User registered or updated successfully." }


Endpoint 2: Session Initiation (for Existing Users)

This endpoint is used every time a registered user opens the app. It syncs their data and FCM token.

Method: POST
Path: /initiate-session
Request Body (JSON):
{
  "user_phone": "972541234567",
  "name": "×™×©×¨××œ ×™×©×¨××œ×™",
  "gender": "male",
  "language": "he", // Optional: "he" or "en". Defaults to "he" if not provided.
  "fcm_token": "dEgPUpGiSd64ytltFCdIWM:APA91b..."
}

Backend Logic:
- Receive the user data.
- This logic is identical to the `/register-user` endpoint. It finds the user by `user_phone` and updates their `name`, `gender`, and ensures the `fcm_token` in the `devices` table is current for that user.

Success Response:
Status Code: 200 OK
Body (JSON): { "status": "success", "message": "Session initiated and user data synchronized." }


Endpoint 3: Conversation Processing

Path: /voice/process
Request Body (JSON):
{
  "user_id": "972541234567", // Normalized phone number
  "message": "The text transcribed from the user's speech.",
  "audio_data": null
}


Endpoint 4: Agent-Initiated Call Answered

Path: /voice/call-answered
Request Body (JSON): { "user_id": "972541234567" }


Endpoint 5: Agent-Initiated Call Declined

Path: /voice/call-declined
Request Body (JSON): { "user_id": "972541234567" }


5. Workflow Walkthroughs

Flow A: First-Time User Registration
1. A new user opens the app and sees the registration screen.
2. The user enters their name, gender, and phone number.
3. The app normalizes the phone number to `972541234567`.
4. The app saves the full profile to local storage.
5. The app gets a unique `fcm_token` from Firebase.
6. The app sends a POST request to `/register-user` with the following body:
   ```json
   {
     "user_phone": "972541234567",
     "name": "×™×©×¨××œ×” ×™×©×¨××œ×™",
     "gender": "female",
     "language": "he",
     "fcm_token": "dEgPUpGiSd6..."
   }
   ```
7. The backend performs an UPSERT operation. Since the user is new, they are inserted into the `users` table. The user proceeds to the HomeScreen.

Flow B: Existing User App Start (Session Initiation)
1. A registered user opens the app.
2. The app reads the saved User Profile (`name`, `gender`, `phone`) from its local storage.
3. The app gets the latest `fcm_token` from Firebase.
4. The app sends a POST request to `/initiate-session` with the following body:
   ```json
   {
     "user_phone": "972541234567",
     "name": "×™×©×¨××œ×” ×™×©×¨××œ×™",
     "gender": "female",
     "language": "he",
     "fcm_token": "dEgPUpGiSd6..."
   }
   ```
5. The backend performs an UPSERT on the `users` table, ensuring the user's data and FCM token are up-to-date.
6. The app proceeds to the HomeScreen.

Flow C: User-Initiated Conversation
1. The user speaks a message. The app transcribes it.
2. The app sends a POST request to /voice/process with the saved user_id and the transcribed message.
3. The backend processes the message and returns the agent's reply.
4. The app speaks the reply. The conversation continues until the user closes the app.
5. Upon closing the app, the app sends one final POST to /voice/process with the message "USER_CLOSED_APP".

Flow D: Agent-Initiated Conversation (Reminder/Ring)
1. An event triggers the agent on the backend for a specific user (identified by user_phone, e.g., 972541234567).
2. The backend queries the users table using 972541234567 to retrieve the corresponding fcm_token.
3. The backend authenticates with Google (using its Service Account key) to get a temporary OAuth 2.0 access token.
4. The backend constructs and sends an HTTP V1 FCM request to Google's servers.
   URL: https://fcm.googleapis.com/v1/projects/mci-assistant/messages:send
   Headers:
     Content-Type: application/json
     Authorization: Bearer <Generated_Access_Token>
   Body (JSON):
   {
     "message": {
       "token": "THE_FCM_TOKEN_FROM_DATABASE",
       "data": {
         "title": "×ª×–×›×•×¨×ª ×—×©×•×‘×”", // The title for the notification UI
         "body": "×©×œ×•×, ×–×” ×”×–×ž×Ÿ ×œ×§×—×ª ××ª ×”×ª×¨×•×¤×” ×©×œ×š." // The text the app will speak when the user answers
       }
     }
   }
5. The mobile app receives the push notification and displays a full-screen "incoming call" interface.
6. User Interaction with "Incoming Call":
   - If the user "answers" the call:
     a. The app first sends a POST request to /voice/call-answered with the `user_id`.
     b. The app then navigates to the main conversation screen.
     c. The app speaks the `body` content from the FCM notification.
     d. The conversation then continues as described in Flow C, starting with the app listening for the user's response.
   - If the user "declines" the call (e.g., presses a decline button):
     a. The app sends a POST request to /voice/call-declined with the `user_id`.
     b. The incoming call screen is dismissed. No further conversation flow is initiated by this event.
   - If the user does not answer (No Answer):
     a. The app does nothing. It does not send any request to the backend.
     b. The backend is responsible for handling this scenario. After sending the notification, the backend will start a timer. If it doesn't receive a `/voice/call-answered` or `/voice/call-declined` request within a configured timeout period, it will assume the user did not answer and proceed with its internal logic (e.g., log a missed notification, retry, or escalate to caregivers).

6. Backend Server Address
Configured Base URL: http://memora.aigents.co.il


