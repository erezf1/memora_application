==================== FILE: lib\firebase_options.dart ====================
// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyBB7AOt_tblA7kuL4lyaWP_eJJFy7ps24U',
    appId: '1:250945452144:web:96c9156892ca202698dcb5',
    messagingSenderId: '250945452144',
    projectId: 'memoraapp-c5a0a',
    authDomain: 'memoraapp-c5a0a.firebaseapp.com',
    storageBucket: 'memoraapp-c5a0a.firebasestorage.app',
    measurementId: 'G-1YFY0H8WGJ',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyAlUpL1VPUAQmJK9RPbLYAGlQucezU7hyw',
    appId: '1:250945452144:android:e612ddfe8c8c0f3c98dcb5',
    messagingSenderId: '250945452144',
    projectId: 'memoraapp-c5a0a',
    storageBucket: 'memoraapp-c5a0a.firebasestorage.app',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyBJxq-z0d0PgbGzrdo4nP4OIa6osQuus7s',
    appId: '1:250945452144:ios:62e40e11b1dfcefd98dcb5',
    messagingSenderId: '250945452144',
    projectId: 'memoraapp-c5a0a',
    storageBucket: 'memoraapp-c5a0a.firebasestorage.app',
    iosBundleId: 'com.example.memoraApplication',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyBJxq-z0d0PgbGzrdo4nP4OIa6osQuus7s',
    appId: '1:250945452144:ios:62e40e11b1dfcefd98dcb5',
    messagingSenderId: '250945452144',
    projectId: 'memoraapp-c5a0a',
    storageBucket: 'memoraapp-c5a0a.firebasestorage.app',
    iosBundleId: 'com.example.memoraApplication',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyBB7AOt_tblA7kuL4lyaWP_eJJFy7ps24U',
    appId: '1:250945452144:web:7f000bc82522884198dcb5',
    messagingSenderId: '250945452144',
    projectId: 'memoraapp-c5a0a',
    authDomain: 'memoraapp-c5a0a.firebaseapp.com',
    storageBucket: 'memoraapp-c5a0a.firebasestorage.app',
    measurementId: 'G-83DNGW4LKD',
  );
}


==================== FILE: lib\main.dart ====================
// lib/main.dart

import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_messaging/firebase_messaging.dart';

import 'firebase_options.dart';
import 'screens/splash_screen.dart';
import 'screens/incoming_call_screen.dart';
import 'services/notification_service.dart';

/// Global navigator key so NotificationService can navigate
/// from notification taps.
final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Register the TOP-LEVEL FCM background handler.
  // (firebaseMessagingBackgroundHandler is defined in notification_service.dart)
  FirebaseMessaging.onBackgroundMessage(firebaseMessagingBackgroundHandler);

  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );

  // Initialize local notifications + FCM listeners.
  await NotificationService.instance.initialize();

  runApp(const MemoraApp());
}

class MemoraApp extends StatelessWidget {
  const MemoraApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      navigatorKey: navigatorKey,
      title: 'Memora',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        visualDensity: VisualDensity.adaptivePlatformDensity,
      ),

      // Splash screen decides if to go to Welcome/Registration
      // or directly to MainConversationScreen.
      home: const SplashScreen(),

      // Optional named route for IncomingCallScreen (kept for completeness).
      routes: {
        IncomingCallScreen.routeName: (context) {
          final args = ModalRoute.of(context)!.settings.arguments
              as Map<String, dynamic>?;

          final callerName = args?['callerName'] as String? ?? 'Unknown';
          final callId = args?['callId'] as String? ?? '';
          final initialMessage = args?['initialMessage'] as String? ?? '';

          return IncomingCallScreen(
            callerName: callerName,
            callId: callId,
            initialMessage: initialMessage,
          );
        },
      },
    );
  }
}


==================== FILE: lib\models\user_profile.dart ====================

class UserProfile {
  final String name;
  final String gender;
  final String phone;
  final String language;
  final String status;

  UserProfile({
    required this.name,
    required this.gender,
    required this.phone,
    required this.language,
    this.status = 'new',
  });

  factory UserProfile.fromJson(Map<String, dynamic> json) => UserProfile(
        name: json['name'],
        gender: json['gender'],
        phone: json['user_phone'],
        language: json['language'],
        status: json['status'] ?? 'new',
      );

  Map<String, dynamic> toJson() => {
        'name': name,
        'gender': gender,
        'user_phone': phone,
        'language': language,
        'status': status,
      };

  UserProfile copyWith({String? status}) {
    return UserProfile(
      name: name,
      gender: gender,
      phone: phone,
      language: language,
      status: status ?? this.status,
    );
  }
}


==================== FILE: lib\screens\incoming_call_screen.dart ====================
// lib/screens/incoming_call_screen.dart

import 'package:flutter/material.dart';

import '../models/user_profile.dart';
import '../services/user_profile_service.dart';
import '../services/api_service.dart';
import '../services/notification_service.dart';
import 'main_conversation_screen.dart';

class IncomingCallScreen extends StatefulWidget {
  static const String routeName = '/incoming_call';

  final String callerName;
  final String callId;
  final String initialMessage; // text the assistant should speak

  const IncomingCallScreen({
    super.key,
    required this.callerName,
    required this.callId,
    required this.initialMessage,
  });

  @override
  State<IncomingCallScreen> createState() => _IncomingCallScreenState();
}

class _IncomingCallScreenState extends State<IncomingCallScreen> {
  final ApiService _apiService = ApiService();
  UserProfile? _userProfile;
  bool _isProcessing = false;

  @override
  void initState() {
    super.initState();
    _loadUserProfile();
  }

  Future<void> _loadUserProfile() async {
    final profile = await UserProfileService.loadProfile();
    setState(() {
      _userProfile = profile;
    });
  }

  Future<void> _declineCall() async {
    if (_isProcessing) return;
    setState(() => _isProcessing = true);

    try {
      final phone = _userProfile?.phone;

      if (phone != null && phone.isNotEmpty) {
        // TODO: implement /voice/call-declined endpoint in ApiService if needed
        // await _apiService.callDeclined(phone);
        print(
            '[IncomingCall] Declined call for user_phone=$phone, callId=${widget.callId}');
      } else {
        print(
            '[IncomingCall] Declined call but user profile/phone is missing.');
      }

      await NotificationService.cancelIncomingCallNotification();
    } finally {
      if (mounted) {
        setState(() => _isProcessing = false);
        Navigator.of(context).pop();
      }
    }
  }

  Future<void> _answerCall() async {
    if (_isProcessing) return;
    setState(() => _isProcessing = true);

    try {
      final phone = _userProfile?.phone;

      if (phone != null && phone.isNotEmpty) {
        // TODO: implement /voice/call-answered endpoint in ApiService if needed
        // await _apiService.callAnswered(phone);
        print(
            '[IncomingCall] Answered call for user_phone=$phone, callId=${widget.callId}');
      } else {
        print(
            '[IncomingCall] Answered call but user profile/phone is missing.');
      }

      await NotificationService.cancelIncomingCallNotification();

      if (!mounted) return;

      // Navigate to the main conversation screen, as in your app flow.
      Navigator.of(context).pushReplacement(
        MaterialPageRoute(
          builder: (_) => MainConversationScreen(
            userPhone: _userProfile?.phone ?? '',
            initialMessage: widget.initialMessage,
          ),
        ),
      );
    } finally {
      if (mounted) {
        setState(() => _isProcessing = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Scaffold(
      backgroundColor: Colors.black,
      body: SafeArea(
        child: Column(
          children: [
            const SizedBox(height: 32),
            Text(
              'שיחה נכנסת', // Incoming call
              style: theme.textTheme.titleMedium?.copyWith(
                color: Colors.white70,
              ),
            ),
            const SizedBox(height: 16),
            Text(
              widget.callerName,
              textAlign: TextAlign.center,
              style: theme.textTheme.headlineMedium?.copyWith(
                color: Colors.white,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              'Memora',
              style: theme.textTheme.bodyMedium?.copyWith(
                color: Colors.white54,
              ),
            ),
            const Spacer(),
            if (_isProcessing)
              const Padding(
                padding: EdgeInsets.only(bottom: 24),
                child: CircularProgressIndicator(
                  valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                ),
              ),
            Padding(
              padding: const EdgeInsets.only(bottom: 40.0),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                children: [
                  _buildActionButton(
                    label: 'דחייה', // Decline
                    icon: Icons.call_end,
                    color: Colors.red,
                    onPressed: _declineCall,
                  ),
                  _buildActionButton(
                    label: 'מענה', // Answer
                    icon: Icons.call,
                    color: Colors.green,
                    onPressed: _answerCall,
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildActionButton({
    required String label,
    required IconData icon,
    required Color color,
    required VoidCallback onPressed,
  }) {
    return Column(
      children: [
        FloatingActionButton(
          heroTag: label,
          onPressed: onPressed,
          backgroundColor: color,
          child: Icon(icon, color: Colors.white),
        ),
        const SizedBox(height: 8),
        Text(
          label,
          style: const TextStyle(
            color: Colors.white,
          ),
        ),
      ],
    );
  }
}


==================== FILE: lib\screens\main_conversation_screen.dart ====================
// lib/screens/main_conversation_screen.dart

import 'package:flutter/material.dart';
import 'package:permission_handler/permission_handler.dart'; // Import permission_handler
import 'package:flutter/services.dart'; // Required for closing the app
// --- FIX APPLIED HERE: Added a line break to correctly import the ApiService ---
import 'splash_screen.dart';
import '../services/api_service.dart';

class MainConversationScreen extends StatefulWidget {
  final String initialMessage;
  final String userPhone;

  const MainConversationScreen({
    super.key,
    required this.userPhone,
    required this.initialMessage,
  });

  @override
  State<MainConversationScreen> createState() => _MainConversationScreenState();
}

class _MainConversationScreenState extends State<MainConversationScreen> {
  final TextEditingController _messageController = TextEditingController();
  final ApiService _apiService = ApiService();
  final List<Map<String, String>> _messages = [];
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    // --- NEW: Log to confirm this screen was created ---
    print("[Flow] MainConversationScreen initState called.");

    // --- NEW: Check for the overlay permission here ---
    _checkAndRequestOverlayPermission();

    if (widget.initialMessage.isNotEmpty) {
      _addMessage('assistant', widget.initialMessage);
    }
  }

  // --- NEW: Function to handle the overlay permission ---
  Future<void> _checkAndRequestOverlayPermission() async {
    print("[Permission] Checking System Alert Window permission...");
    final status = await Permission.systemAlertWindow.status;
    print("[Permission] Current System Alert Window status: $status");

    if (status.isGranted) {
      print("[Permission] System Alert Window permission is granted.");
      return;
    }

    // If not granted, request it. This will open the app settings screen for the user.
    print(
        "[Permission] System Alert Window permission not granted. Requesting...");
    // We don't await this to avoid blocking the UI, but it will open settings.
    await Permission.systemAlertWindow.request();
  }

  void _addMessage(String sender, String text) {
    setState(() {
      _messages.insert(0, {'sender': sender, 'text': text});
    });
  }

  Future<void> _sendMessage() async {
    if (_messageController.text.isEmpty || _isLoading) {
      return;
    }

    final String messageText = _messageController.text;
    _addMessage('user', messageText);
    _messageController.clear();

    setState(() {
      _isLoading = true;
    });

    try {
      final String reply =
          await _apiService.sendMessage(widget.userPhone, messageText);
      _addMessage('assistant', reply);
    } catch (e) {
      _addMessage('assistant', 'Sorry, I ran into an error. Please try again.');
      print('Error sending message: $e');
    } finally {
      setState(() {
        _isLoading = false;
      });
    }
  }

  // --- HANG UP BUTTON FUNCTIONALITY - UPDATED ---
  Future<void> _hangUp() async {
    // 1. First, inform the backend that the user is disconnecting.
    // We use widget.userPhone to identify the user.
    await _apiService.disconnect(widget.userPhone);

    // --- FIX: Use a MethodChannel to reliably move the app to the background ---
    // This is more compatible than SystemNavigator.sendToBackground().
    const platform = MethodChannel('com.example.memora_application/native');
    await platform.invokeMethod('sendToBackground');
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        backgroundColor: Colors.blue,
        title: const Text('Memora', style: TextStyle(color: Colors.white)),
        iconTheme: const IconThemeData(color: Colors.white),
        actionsIconTheme: const IconThemeData(color: Colors.white),
        actions: [
          IconButton(
            icon: const Icon(Icons.call_end, color: Colors.redAccent, size: 28),
            onPressed: _hangUp,
            tooltip: 'Close App',
          ),
          const SizedBox(width: 8),
        ],
      ),
      body: SafeArea(
        child: Column(
          children: [
            Expanded(
              child: ListView.builder(
                reverse: true,
                padding: const EdgeInsets.all(8.0),
                itemCount: _messages.length,
                itemBuilder: (context, index) {
                  final message = _messages[index];
                  final isUser = message['sender'] == 'user';
                  return Align(
                    alignment:
                        isUser ? Alignment.centerRight : Alignment.centerLeft,
                    child: Container(
                      margin: const EdgeInsets.symmetric(
                          vertical: 5, horizontal: 10),
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        color: isUser ? Colors.blue[100] : Colors.grey[200],
                        borderRadius: BorderRadius.circular(15),
                      ),
                      child: Text(message['text']!),
                    ),
                  );
                },
              ),
            ),
            if (_isLoading) const LinearProgressIndicator(),
            _buildTextComposer(),
          ],
        ),
      ),
    );
  }

  Widget _buildTextComposer() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 8.0),
      child: Row(
        children: [
          Expanded(
            child: TextField(
              controller: _messageController,
              decoration: InputDecoration(
                hintText: 'Type your message...',
                filled: true,
                fillColor: Colors.grey[100],
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(20),
                  borderSide: BorderSide.none,
                ),
              ),
              onSubmitted: (_) => _sendMessage(),
            ),
          ),
          const SizedBox(width: 8),
          IconButton(
            icon: const Icon(Icons.send, color: Colors.blue),
            onPressed: _sendMessage,
          ),
        ],
      ),
    );
  }
}


==================== FILE: lib\screens\registration_screen.dart ====================
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:permission_handler/permission_handler.dart';
import '../models/user_profile.dart';
import '../services/api_service.dart';
import 'main_conversation_screen.dart';
import '../services/user_profile_service.dart';

class RegistrationScreen extends StatefulWidget {
  @override
  _RegistrationScreenState createState() => _RegistrationScreenState();
}

class _RegistrationScreenState extends State<RegistrationScreen> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _phoneController = TextEditingController();
  String _selectedGender = 'male';
  String _selectedLanguage = 'en';

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Registration')),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: SingleChildScrollView(
          child: Form(
            key: _formKey,
            child: Column(
              children: <Widget>[
                TextFormField(
                  controller: _nameController,
                  decoration: InputDecoration(labelText: 'Full Name'),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter your name';
                    }
                    return null;
                  },
                ),
                TextFormField(
                  controller: _phoneController,
                  decoration: InputDecoration(labelText: 'Phone Number'),
                  keyboardType: TextInputType.phone,
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter your phone number';
                    }
                    return null;
                  },
                ),
                DropdownButtonFormField<String>(
                  value: _selectedGender,
                  decoration: InputDecoration(labelText: 'Gender'),
                  items: ['male', 'female', 'other'].map((String value) {
                    return DropdownMenuItem<String>(
                      value: value,
                      child: Text(value),
                    );
                  }).toList(),
                  onChanged: (newValue) {
                    setState(() {
                      _selectedGender = newValue!;
                    });
                  },
                ),
                DropdownButtonFormField<String>(
                  value: _selectedLanguage,
                  decoration: InputDecoration(labelText: 'Language'),
                  items: ['en', 'he'].map((String value) {
                    return DropdownMenuItem<String>(
                      value: value,
                      child: Text(value),
                    );
                  }).toList(),
                  onChanged: (newValue) {
                    setState(() {
                      _selectedLanguage = newValue!;
                    });
                  },
                ),
                SizedBox(height: 20),
                ElevatedButton(
                  onPressed: _register,
                  child: Text('Register'),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  void _register() async {
    print("[Flow] RegistrationScreen: 'Register' pressed.");
    if (_formKey.currentState!.validate()) {
      // Get FCM token
      String? fcmToken = await FirebaseMessaging.instance.getToken();
      if (fcmToken == null) {
        print('Failed to get FCM token');
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content:
                  Text('Could not get notification token. Please try again.')),
        );
        return;
      }

      print(
          "[Flow] RegistrationScreen: Got FCM Token. Preparing user profile...");
      // Normalize phone number
      String normalizedPhone = '972' + _phoneController.text.substring(1);

      // Create user profile with 'registering' status
      UserProfile userProfile = UserProfile(
        name: _nameController.text,
        gender: _selectedGender,
        phone: normalizedPhone,
        language: _selectedLanguage,
        status: 'registering',
      );
      print(
          "[Flow] RegistrationScreen: Saving 'registering' profile locally...");
      await UserProfileService.saveProfile(userProfile);

      // Log the data being sent
      final userData = {
        ...userProfile.toJson(),
        'fcm_token': fcmToken,
      };
      print('Attempting to register user with data: ${jsonEncode(userData)}');

      try {
        print("[Flow] RegistrationScreen: Calling backend registerUser API...");
        final registrationData =
            await ApiService().registerUser(userProfile, fcmToken);

        // Update profile to 'active'
        final activeProfile = userProfile.copyWith(status: 'active');
        print(
            "[Flow] RegistrationScreen: Backend registration successful. Saving 'active' profile locally...");
        await UserProfileService.saveProfile(activeProfile);

        print('Registration successful!');

        final String initialMessage = registrationData['initial_message'] ??
            "Welcome! How can I help you?";

        print('[Flow] Preparing to navigate to MainConversationScreen...');
        // Use `mounted` check to ensure the widget is still in the tree before navigating.
        if (!mounted) return;

        Navigator.pushReplacement(
          context,
          MaterialPageRoute(
              builder: (context) => MainConversationScreen(
                  userPhone: normalizedPhone, initialMessage: initialMessage)),
        );
        print('[Flow] Navigation command sent.');
      } catch (e) {
        print('Registration failed with error: $e');
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Registration failed: $e')),
        );
      }
    }
  }
}


==================== FILE: lib\screens\splash_screen.dart ====================
// lib/screens/splash_screen.dart

import 'package:flutter/material.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:permission_handler/permission_handler.dart';
import '../models/user_profile.dart';
import '../services/user_profile_service.dart';
import '../services/api_service.dart';
import 'main_conversation_screen.dart';
import 'welcome_screen.dart';

class SplashScreen extends StatefulWidget {
  const SplashScreen({super.key});

  @override
  State<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends State<SplashScreen> {
  @override
  void initState() {
    super.initState();
    print("[Flow] SplashScreen.initState(): Starting.");
    _determineInitialRoute();
  }

  /// A generic function to check and print the status of all relevant permissions.
  Future<void> _checkAllPermissions() async {
    print("--- [Generic Permission Check] Starting ---");

    final permissions = [
      Permission.microphone,
      Permission.notification,
      Permission.location,
      Permission.systemAlertWindow, // "Display over other apps"
    ];

    for (var permission in permissions) {
      final status = await permission.status;
      // The permission name is long, so we split it to get the last part.
      print(
          "[Generic Permission Check] ${permission.toString().split('.').last}: $status");
    }
    print("--- [Generic Permission Check] Finished ---");
  }

  Future<void> _determineInitialRoute() async {
    print("[Flow] SplashScreen: Determining initial route...");
    // Give the splash screen a moment to be visible
    await Future.delayed(const Duration(seconds: 1));

    print("[Flow] SplashScreen: Loading user profile...");
    final userProfile = await UserProfileService.loadProfile();

    // Run our generic permission check for debugging purposes.
    await _checkAllPermissions();

    // If no profile exists or status is not 'active', go to registration flow.
    if (userProfile == null || userProfile.status != 'active') {
      print(
          "[Flow] SplashScreen: No active profile found. Navigating to WelcomeScreen.");
      if (mounted) {
        Navigator.of(context).pushReplacement(
            MaterialPageRoute(builder: (_) => const WelcomeScreen()));
      }
      return;
    }

    print(
        "[Flow] SplashScreen: Active profile found. Verifying user with backend...");
    // If profile exists, verify the user and go to the main screen.
    try {
      final fcmToken = await FirebaseMessaging.instance.getToken();
      final verificationData =
          await ApiService().verifyUser(userProfile, fcmToken!);
      if (mounted) {
        print(
            "[Flow] SplashScreen: User verified. Navigating to MainConversationScreen.");
        Navigator.of(context).pushReplacement(MaterialPageRoute(
            builder: (_) => MainConversationScreen(
                userPhone: userProfile.phone,
                initialMessage:
                    verificationData['message'] ?? 'Welcome back!')));
      }
    } catch (e) {
      // If verification fails, delete the stale profile and go to registration.
      print(
          "[Flow] SplashScreen: User verification failed ($e). Deleting stale profile and navigating to WelcomeScreen.");
      await UserProfileService.deleteProfile();
      if (mounted) {
        Navigator.of(context).pushReplacement(
            MaterialPageRoute(builder: (_) => const WelcomeScreen()));
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return const Scaffold(
      body: Center(
        child: CircularProgressIndicator(),
      ),
    );
  }
}


==================== FILE: lib\screens\welcome_screen.dart ====================
// lib/screens/welcome_screen.dart

import 'package:flutter/material.dart';
import 'registration_screen.dart';
import 'package:permission_handler/permission_handler.dart';

class WelcomeScreen extends StatelessWidget {
  const WelcomeScreen({super.key});

  // This is your existing function to handle permissions and navigation.
  Future<void> _continue(BuildContext context) async {
    print(
        "[Flow] WelcomeScreen: 'Continue' pressed. Requesting standard permissions...");
    // Request all necessary permissions at once.
    await [
      Permission.notification,
      Permission.microphone,
      Permission.location,
    ].request();
    print(
        "[Flow] WelcomeScreen: Standard permissions requested. Navigating to RegistrationScreen.");

    // Navigate to the RegistrationScreen.
    // We use pushReplacement to prevent the user from navigating back to the welcome screen.
    Navigator.pushReplacement(
      context,
      // --- FIX #1: Removed the 'const' keyword ---
      // RegistrationScreen is a StatefulWidget and does not have a const constructor.
      MaterialPageRoute(builder: (_) => RegistrationScreen()),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(20),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              const SizedBox(height: 40),

              // Your logo from the assets folder.
              Image.asset('assets/images/logo.png', height: 150, width: 150),

              const SizedBox(height: 20),

              const Text(
                "קַבָּלַת פָּנִים!", // "Welcome!" in Hebrew
                style: TextStyle(
                    fontSize: 32,
                    fontWeight: FontWeight.bold,
                    color: Colors.black),
              ),

              const SizedBox(height: 10),

              const Text(
                "נדריך אותך צעד אחר צעד.", // "We will guide you step by step."
                style: TextStyle(fontSize: 18, color: Colors.black87),
              ),

              const SizedBox(height: 40),

              const Text(
                "כדי להשתמש בעוזר, אנו זקוקים לגישה ל:", // "To use the assistant, we need access to:"
                style: TextStyle(fontSize: 18, color: Colors.black),
                textAlign: TextAlign.center,
              ),

              const SizedBox(height: 20),

              // Re-using your infoRow helper widget.
              infoRow(Icons.mic,
                  "מיקרופון לפקודות קוליות"), // "Microphone for voice commands"
              infoRow(Icons.location_on,
                  "מיקום לשירותים שימושיים"), // "Location for useful services"
              infoRow(Icons.notifications,
                  "התראות שיסייעו לך"), // "Notifications to help you"

              const Spacer(), // This pushes the button to the bottom.

              SizedBox(
                width: double.infinity,
                height: 55,
                child: ElevatedButton(
                  onPressed: () => _continue(context),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.blue,
                    // --- FIX #2: Corrected the typo in the class name ---
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(10),
                    ),
                  ),
                  child: const Text(
                    "לְהַמשִׁיך", // "Continue"
                    style: TextStyle(
                        fontSize: 22,
                        color: Colors.white,
                        fontWeight: FontWeight.bold),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  // Helper widget for displaying permission information rows.
  Widget infoRow(IconData icon, String text) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(icon, color: Colors.blue, size: 28),
          const SizedBox(width: 15),
          // Use Expanded to make sure text wraps gracefully on smaller screens.
          Expanded(
            child: Text(
              text,
              style: const TextStyle(fontSize: 16, color: Colors.black54),
              textAlign: TextAlign.start,
            ),
          ),
        ],
      ),
    );
  }
}


==================== FILE: lib\services\api_service.dart ====================
// lib/services/api_service.dart

import 'dart:convert';
import 'dart:async';
import 'package:http/http.dart' as http;
import '../models/user_profile.dart';

class ApiService {
  // === CONFIGURATION ===
  static const String _baseUrl = 'http://memora.aigents.co.il';
  static const Duration _timeoutDuration = Duration(seconds: 20);

  // === PRIVATE HELPER METHOD ===
  static http.Response _handleResponse(http.Response response) {
    if (response.statusCode >= 200 && response.statusCode < 300) {
      return response;
    } else {
      throw Exception(
        'API Error: Status ${response.statusCode}, Body: ${response.body}',
      );
    }
  }

  // === PUBLIC API METHODS ===

  Future<Map<String, dynamic>> registerUser(
      UserProfile profile, String fcmToken) async {
    final url = Uri.parse('$_baseUrl/register-user');
    final requestBody = profile.toJson();
    requestBody['fcm_token'] = fcmToken;
    if (requestBody.containsKey('phone')) {
      requestBody['user_phone'] = requestBody['phone'];
      requestBody.remove('phone');
    }

    print('Sending POST request to: $url');
    print('With body: ${json.encode(requestBody)}');

    try {
      final response = await http
          .post(
            url,
            headers: {'Content-Type': 'application/json; charset=UTF-8'},
            body: json.encode(requestBody),
          )
          .timeout(_timeoutDuration);

      final handledResponse = _handleResponse(response);
      return json.decode(utf8.decode(handledResponse.bodyBytes));
    } catch (e) {
      print('Error during user registration: $e');
      rethrow;
    }
  }

  Future<Map<String, dynamic>> verifyUser(
      UserProfile profile, String fcmToken) async {
    final url = Uri.parse('$_baseUrl/initiate-session');
    final requestBody = profile.toJson();
    requestBody['fcm_token'] = fcmToken;
    if (requestBody.containsKey('phone')) {
      requestBody['user_phone'] = requestBody['phone'];
      requestBody.remove('phone');
    }

    print('Sending POST request to: $url');
    print('With body: ${json.encode(requestBody)}');

    try {
      final response = await http
          .post(
            url,
            headers: {'Content-Type': 'application/json; charset=UTF-8'},
            body: json.encode(requestBody),
          )
          .timeout(_timeoutDuration);

      final handledResponse = _handleResponse(response);
      return json.decode(utf8.decode(handledResponse.bodyBytes));
    } catch (e) {
      print('Error during user verification: $e');
      rethrow;
    }
  }

  Future<String> sendMessage(String userPhone, String message) async {
    final url = Uri.parse('$_baseUrl/voice/process');
    print('Sending POST request to: $url');
    // --- NEW: Log the content of the message being sent ---
    print('Sending message content: $message');

    try {
      final response = await http
          .post(
            url,
            headers: {'Content-Type': 'application/json; charset=UTF-8'},
            body: json.encode({
              'user_id': userPhone,
              'message': message,
              'audio_data': null,
            }),
          )
          .timeout(_timeoutDuration);

      final handledResponse = _handleResponse(response);
      String reply = utf8.decode(handledResponse.bodyBytes);

      // --- NEW: Log the content of the reply received from the backend ---
      print('Received reply content: $reply');

      if (reply.startsWith('"') && reply.endsWith('"')) {
        reply = reply.substring(1, reply.length - 1);
      }

      if (reply.isNotEmpty) {
        return reply;
      } else {
        throw Exception(
            'API Error: Received an empty response from /voice/process.');
      }
    } catch (e) {
      print('Error sending message: $e');
      rethrow;
    }
  }

  // --- NEW DISCONNECT METHOD ---
  Future<void> disconnect(String userPhone) async {
    final url = Uri.parse('$_baseUrl/disconnect');
    print('Sending POST request to: $url');

    try {
      // We don't need to wait long for this. If it fails, the app still closes.
      await http
          .post(
            url,
            headers: {'Content-Type': 'application/json; charset=UTF-8'},
            body: json.encode({'user_phone': userPhone}),
          )
          .timeout(const Duration(seconds: 5));

      print('Disconnect message sent successfully for $userPhone.');
    } catch (e) {
      // We log the error but don't rethrow it, so the app can still close
      // even if the disconnect message fails to send (e.g., no network).
      print('Could not send disconnect message: $e');
    }
  }

  // --- NEW METHOD 1: answerCall ---
  /// Informs the backend that the user has answered a proactive "call".
  Future<Map<String, dynamic>> answerCall(
      String userPhone, String callId) async {
    final url = Uri.parse('$_baseUrl/answer-call');
    final body = {'user_phone': userPhone, 'call_id': callId};
    print('Sending POST request to: $url with body: ${json.encode(body)}');

    try {
      final response = await http
          .post(
            url,
            headers: {'Content-Type': 'application/json; charset=UTF-8'},
            body: json.encode(body),
          )
          .timeout(const Duration(seconds: 10));

      final handledResponse = _handleResponse(response);
      print('Successfully sent answer-call.');
      // Decode and return the JSON body from the response.
      return json.decode(utf8.decode(handledResponse.bodyBytes));
    } catch (e) {
      print('Failed to send answer-call: $e');
      rethrow; // Rethrow to let the UI know the call failed
    }
  }

  // --- NEW METHOD 2: declineCall ---
  /// Informs the backend that the user has declined a proactive "call".
  Future<void> declineCall(String userPhone, String callId) async {
    final url = Uri.parse('$_baseUrl/decline-call');
    final body = {'user_phone': userPhone, 'call_id': callId};
    print('Sending POST request to: $url with body: ${json.encode(body)}');

    try {
      await http
          .post(
            url,
            headers: {'Content-Type': 'application/json; charset=UTF-8'},
            body: json.encode(body),
          )
          .timeout(const Duration(seconds: 10));

      print('Successfully sent decline-call.');
    } catch (e) {
      // We don't rethrow here, as the UI should close even if the decline message fails.
      print('Failed to send decline-call: $e');
    }
  }
}


==================== FILE: lib\services\notification_service.dart ====================
import 'dart:convert';

import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter/material.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';

import '../screens/main_conversation_screen.dart';
import '../screens/incoming_call_screen.dart';
import '../main.dart'; // for navigatorKey

/// Channel / notification ids
const String _incomingCallChannelId = 'memora_incoming_call_channel';
const String _incomingCallChannelName = 'Memora Incoming Calls';
const String _incomingCallChannelDescription =
    'High priority incoming-call style notifications for Memora';

const int _incomingCallNotificationId = 1001;

/// Android action ids
const String _answerActionId = 'ANSWER_ACTION';
const String _declineActionId = 'DECLINE_ACTION';

/// TOP-LEVEL background handler for FCM.
///
/// Must be a top-level or static function and annotated as entry point so
/// it is kept in AOT.
@pragma('vm:entry-point')
Future<void> firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  debugPrint('[NotificationService] TOP-LEVEL BG HANDLER START');
  debugPrint(
      '[NotificationService] [BG] messageId: ${message.messageId ?? "null"}');
  debugPrint(
      '[NotificationService] [BG] raw data: ${message.data.isEmpty ? "{}" : message.data.toString()}');
  debugPrint(
      '[NotificationService] [BG] notification: ${message.notification}');

  await Firebase.initializeApp();
  debugPrint('[NotificationService] [BG] Firebase.initializeApp() done');

  await NotificationService.instance._ensureLocalNotificationsInitialized();
  debugPrint(
      '[NotificationService] [BG] Local notifications plugin initialized');

  // Treat this as "background" presentation source
  await NotificationService.instance
      ._handleRemoteMessage(message, source: 'background');

  debugPrint('[NotificationService] TOP-LEVEL BG HANDLER END');
}

/// TOP-LEVEL background tap handler for local notifications.
///
/// This is required by flutter_local_notifications for
/// onDidReceiveBackgroundNotificationResponse.
@pragma('vm:entry-point')
void notificationTapBackground(NotificationResponse response) {
  // Just delegate to the instance method
  NotificationService.instance.handleNotificationResponse(response);
}

class NotificationService {
  NotificationService._internal();
  static final NotificationService instance = NotificationService._internal();

  final FlutterLocalNotificationsPlugin _localNotificationsPlugin =
      FlutterLocalNotificationsPlugin();

  bool _initialized = false;

  Future<void> initialize() async {
    if (_initialized) return;

    debugPrint('[NotificationService] initialize() called');

    await _ensureLocalNotificationsInitialized();

    // Attach foreground listeners
    FirebaseMessaging.onMessage.listen(
      (RemoteMessage message) async {
        debugPrint(
            '[NotificationService] onMessage (foreground FCM) received: ${message.messageId}');
        await _handleRemoteMessage(message, source: 'foreground');
      },
    );

    FirebaseMessaging.onMessageOpenedApp.listen(
      (RemoteMessage message) async {
        debugPrint(
            '[NotificationService] onMessageOpenedApp (tap from system tray) for messageId=${message.messageId}');
        await _handleRemoteMessage(message, source: 'opened_app');
      },
    );

    // Handle the case where the app was launched from a terminated state
    // by tapping on a notification.
    final initialMsg = await FirebaseMessaging.instance.getInitialMessage();
    if (initialMsg != null) {
      debugPrint(
          '[NotificationService] getInitialMessage() returned a message. Handling as opened_app.');
      await _handleRemoteMessage(initialMsg, source: 'opened_app');
    } else {
      debugPrint(
          '[NotificationService] getInitialMessage() returned null (no launch-from-notification)');
    }

    _initialized = true;
  }

  Future<void> _ensureLocalNotificationsInitialized() async {
    // Android initialization
    const AndroidInitializationSettings androidInitSettings =
        AndroidInitializationSettings('@mipmap/ic_launcher');

    const InitializationSettings initSettings =
        InitializationSettings(android: androidInitSettings);

    await _localNotificationsPlugin.initialize(
      initSettings,
      // Foreground / already-running case: we can use an instance method.
      onDidReceiveNotificationResponse: handleNotificationResponse,
      // Background tap: MUST be top-level or static.
      onDidReceiveBackgroundNotificationResponse: notificationTapBackground,
    );

    debugPrint('[NotificationService] Local notifications plugin initialized');

    // Create the incoming-call notification channel.
    const AndroidNotificationChannel incomingCallChannel =
        AndroidNotificationChannel(
      _incomingCallChannelId,
      _incomingCallChannelName,
      description: _incomingCallChannelDescription,
      importance: Importance.max,
      playSound: true,
      showBadge: true,
    );

    final androidPlugin =
        _localNotificationsPlugin.resolvePlatformSpecificImplementation<
            AndroidFlutterLocalNotificationsPlugin>();
    await androidPlugin?.createNotificationChannel(incomingCallChannel);
  }

  // ---------------------------------------------------------------------------
  // Handling incoming FCM
  // ---------------------------------------------------------------------------

  Future<void> _handleRemoteMessage(RemoteMessage message,
      {required String source}) async {
    debugPrint('[NotificationService] _handleRemoteMessage() from $source');

    final data = message.data;
    final notification = message.notification;

    debugPrint('[NotificationService]   data: $data');
    debugPrint('[NotificationService]   notification: $notification');

    // Extract common fields
    final String? type = data['type'] as String?;
    final String title =
        data['caller_name'] as String? ?? notification?.title ?? 'Memora';
    final String body = data['description'] as String? ??
        notification?.body ??
        'You have a new message from Memora.';
    final String? callerName = data['caller_name'] as String? ?? title;
    final String? callId = data['call_id'] as String?;
    final String? userPhone = data['user_phone'] as String?;

    debugPrint(
        '[NotificationService]   computed title="$title" body="$body" type="$type" callerName="$callerName" callId="$callId" userPhone="$userPhone"');

    final bool isIncomingCall = type == 'incoming_call' && callId != null;
    debugPrint('[NotificationService]   isIncomingCall=$isIncomingCall');

    if (isIncomingCall) {
      debugPrint(
          '[NotificationService]   Showing INCOMING CALL notification: callerName="$callerName", callId="$callId"');
      await _showIncomingCallNotification(
        callerName: callerName ?? 'Memora',
        callId: callId,
        initialMessage: body,
        userPhone: userPhone,
        presentationSource: source,
      );
    } else {
      // Fallback for generic notifications if you add them in the future
      await _showSimpleNotification(title: title, body: body, data: data);
    }
  }

  // ---------------------------------------------------------------------------
  // Showing notifications
  // ---------------------------------------------------------------------------

  Future<void> _showIncomingCallNotification({
    required String callerName,
    required String callId,
    required String initialMessage,
    required String? userPhone,
    required String presentationSource,
  }) async {
    debugPrint(
        '[NotificationService] _showIncomingCallNotification(): callerName="$callerName", callId="$callId", initialMessage="$initialMessage", userPhone="$userPhone"');

    const AndroidNotificationDetails androidDetails =
        AndroidNotificationDetails(
      _incomingCallChannelId,
      _incomingCallChannelName,
      channelDescription: _incomingCallChannelDescription,
      importance: Importance.max,
      priority: Priority.high,
      category: AndroidNotificationCategory.call,
      fullScreenIntent:
          true, // important for lockscreen / heads-up call-like UI
      ongoing: true,
      autoCancel: false,
      playSound: true,
      ticker: 'Memora incoming call',
      actions: <AndroidNotificationAction>[
        AndroidNotificationAction(
          _answerActionId,
          'Answer',
          showsUserInterface: true,
          cancelNotification: true,
        ),
        AndroidNotificationAction(
          _declineActionId,
          'Decline',
          showsUserInterface: true,
          cancelNotification: true,
        ),
      ],
    );

    const NotificationDetails details =
        NotificationDetails(android: androidDetails);

    final payload = jsonEncode({
      'type': 'incoming_call',
      'callerName': callerName,
      'callId': callId,
      'initialMessage': initialMessage,
      'userPhone': userPhone,
      // how the message was presented (foreground / background / opened_app)
      'presentationSource': presentationSource,
    });

    await _localNotificationsPlugin.show(
      _incomingCallNotificationId,
      callerName,
      initialMessage,
      details,
      payload: payload,
    );

    debugPrint(
        '[NotificationService] _showIncomingCallNotification(): show() completed');
  }

  Future<void> _showSimpleNotification({
    required String title,
    required String body,
    Map<String, dynamic>? data,
  }) async {
    const AndroidNotificationDetails androidDetails =
        AndroidNotificationDetails(
      'memora_default_channel',
      'Memora Notifications',
      channelDescription: 'General notifications from Memora',
      importance: Importance.high,
      priority: Priority.high,
      playSound: true,
    );

    const NotificationDetails details =
        NotificationDetails(android: androidDetails);

    final payload = jsonEncode({
      'type': 'generic',
      'title': title,
      'body': body,
      if (data != null) 'data': data,
    });

    await _localNotificationsPlugin.show(
      0,
      title,
      body,
      details,
      payload: payload,
    );
  }

  // ---------------------------------------------------------------------------
  // Notification response handling
  // ---------------------------------------------------------------------------

  /// Called for **foreground / active** notifications,
  /// and also via [notificationTapBackground] when the app is brought back
  /// from the background by tapping on a notification.
  void handleNotificationResponse(NotificationResponse response) {
    debugPrint('[NotificationService] handleNotificationResponse() called');
    debugPrint('[NotificationService]   actionId: ${response.actionId}');
    debugPrint('[NotificationService]   input: ${response.input}');
    debugPrint(
        '[NotificationService]   payload: ${response.payload ?? "null"}');

    if (response.payload == null) {
      return;
    }

    final Map<String, dynamic> data =
        jsonDecode(response.payload!) as Map<String, dynamic>;
    final String? type = data['type'] as String?;
    debugPrint('[NotificationService]   decoded type="$type" data=$data');

    if (type == 'incoming_call') {
      _handleIncomingCallNotificationResponse(response, data);
    } else {
      // generic notifications, if any, could be handled here
    }
  }

  void _handleIncomingCallNotificationResponse(
    NotificationResponse response,
    Map<String, dynamic> data,
  ) {
    final String? callerName = data['callerName'] as String?;
    final String? callId = data['callId'] as String?;
    final String? initialMessage = data['initialMessage'] as String?;
    final String? userPhone = data['userPhone'] as String?;
    final String? presentationSource = data['presentationSource'] as String?;
    final String actionId = response.actionId ?? '';

    if (callId == null) {
      debugPrint(
          '[NotificationService]   Incoming call payload missing callId. Ignoring.');
      return;
    }

    final cameFromBackground = presentationSource == 'background';

    if (actionId == _declineActionId) {
      // User explicitly declined the call
      debugPrint(
          '[NotificationService]   DECLINE action. Staying where we are.');
      cancelIncomingCallNotification();
      // Optionally notify server later.
      return;
    }

    // ANSWER or body tap
    debugPrint(
        '[NotificationService]   ANSWER (or body tap). presentationSource="$presentationSource"');

    final String safeInitialMessage =
        initialMessage ?? 'Hello, how can I help?';

    if (cameFromBackground) {
      // PHONE LOCKED / APP IN BACKGROUND CASE
      // → open IncomingCallScreen first, and let it handle answerCall + navigation
      debugPrint(
          '[NotificationService]   Navigating to IncomingCallScreen with callerName="$callerName", callId="$callId"');
      cancelIncomingCallNotification();

      _navigateToIncomingCallScreen(
        callerName: callerName ?? 'Memora',
        callId: callId,
        initialMessage: safeInitialMessage,
      );
    } else {
      // PHONE IN USE (FOREGROUND / OPENED_APP)
      // → go directly to MainConversationScreen with the text on top.
      debugPrint(
          '[NotificationService]   Navigating directly to MainConversationScreen with userPhone="$userPhone", callId="$callId"');

      cancelIncomingCallNotification();

      if (userPhone == null || userPhone.isEmpty) {
        debugPrint(
            '[NotificationService]   No userPhone in payload; cannot navigate to MainConversationScreen.');
        return;
      }

      _navigateToMainConversationScreen(
        userPhone: userPhone,
        initialMessage: safeInitialMessage,
      );
    }
  }

  // ---------------------------------------------------------------------------
  // Navigation helpers
  // ---------------------------------------------------------------------------

  void _navigateToIncomingCallScreen({
    required String callerName,
    required String callId,
    required String initialMessage,
  }) {
    final nav = navigatorKey.currentState;
    if (nav == null) {
      debugPrint(
          '[NotificationService] navigatorKey.currentState is null, cannot navigate to IncomingCallScreen.');
      return;
    }

    nav.pushAndRemoveUntil(
      MaterialPageRoute(
        builder: (_) => IncomingCallScreen(
          callerName: callerName,
          callId: callId,
          initialMessage: initialMessage,
        ),
      ),
      (route) => false,
    );
  }

  void _navigateToMainConversationScreen({
    required String userPhone,
    required String initialMessage,
  }) {
    final nav = navigatorKey.currentState;
    if (nav == null) {
      debugPrint(
          '[NotificationService] navigatorKey.currentState is null, cannot navigate to MainConversationScreen.');
      return;
    }

    nav.pushAndRemoveUntil(
      MaterialPageRoute(
        builder: (_) => MainConversationScreen(
          userPhone: userPhone,
          initialMessage: initialMessage,
        ),
      ),
      (route) => false,
    );
  }

  // ---------------------------------------------------------------------------
  // Public util
  // ---------------------------------------------------------------------------

  static Future<void> cancelIncomingCallNotification() async {
    await instance._localNotificationsPlugin
        .cancel(_incomingCallNotificationId);
  }
}


==================== FILE: lib\services\user_profile_service.dart ====================

import 'dart:convert';
import '../models/user_profile.dart';
import 'package:shared_preferences/shared_preferences.dart';

class UserProfileService {
  static const _key = 'user_profile';

  static Future<void> saveProfile(UserProfile profile) async {
    final prefs = await SharedPreferences.getInstance();
    final jsonString = jsonEncode(profile.toJson());
    await prefs.setString(_key, jsonString);
  }

  static Future<UserProfile?> loadProfile() async {
    final prefs = await SharedPreferences.getInstance();
    final jsonString = prefs.getString(_key);
    if (jsonString != null) {
      return UserProfile.fromJson(jsonDecode(jsonString));
    }
    return null;
  }

  static Future<void> deleteProfile() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_key);
  }
}


==================== FILE: lib\utils\constants.dart ====================

const String BASE_URL = 'http://memora.aigents.co.il';


==================== FILE: android\build.gradle.kts ====================
allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

val newBuildDir: Directory = rootProject.layout.buildDirectory.dir("../../build").get()
rootProject.layout.buildDirectory.value(newBuildDir)

subprojects {
    val newSubprojectBuildDir: Directory = newBuildDir.dir(project.name)
    project.layout.buildDirectory.value(newSubprojectBuildDir)
}
subprojects {
    project.evaluationDependsOn(":app")
}

tasks.register<Delete>("clean") {
    delete(rootProject.layout.buildDirectory)
}


==================== FILE: android\settings.gradle.kts ====================
pluginManagement {
    val flutterSdkPath = run {
        val properties = java.util.Properties()
        file("local.properties").inputStream().use { properties.load(it) }
        val flutterSdkPath = properties.getProperty("flutter.sdk")
        require(flutterSdkPath != null) { "flutter.sdk not set in local.properties" }
        flutterSdkPath
    }

    includeBuild("$flutterSdkPath/packages/flutter_tools/gradle")

    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

plugins {
    id("dev.flutter.flutter-plugin-loader") version "1.0.0"
    id("com.android.application") version "8.7.3" apply false
    id("org.jetbrains.kotlin.android") version "2.1.0" apply false
}

include(":app")


==================== FILE: android\app\build.gradle.kts ====================
plugins {
    id("com.android.application")
    id("kotlin-android")
    // The Flutter Gradle Plugin must be applied after the Android and Kotlin Gradle plugins.
    id("dev.flutter.flutter-gradle-plugin")
}

android {
    namespace = "com.example.memora_application"
    compileSdk = 35
    ndkVersion = flutter.ndkVersion

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
        // Required for flutter_local_notifications
        isCoreLibraryDesugaringEnabled = true
    }

    kotlinOptions {
        jvmTarget = "17"
    }

        defaultConfig {
            // TODO: Specify your own unique Application ID (https://developer.android.com/studio/build/application-id.html).
            applicationId = "com.example.memora_application"
            // You can update the following values to match your application needs.
            // For more information, see: https://flutter.dev/to/review-gradle-config.
            minSdk = 23
            targetSdk = flutter.targetSdkVersion
            versionCode = flutter.versionCode
            versionName = flutter.versionName
            ndkVersion = "27.0.12077973" // Add this line
        }

        buildTypes {
            release {
                // TODO: Add your own signing config for the release build.
                // Signing with the debug keys for now, so `flutter run --release` works.
                signingConfig = signingConfigs.getByName("debug")
            }
        }
}

dependencies {
    // Required for flutter_local_notifications
    coreLibraryDesugaring("com.android.tools:desugar_jdk_libs:2.0.4")
}

flutter {
    source = "../.."
}


==================== FILE: android\app\src\debug\AndroidManifest.xml ====================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>


==================== FILE: android\app\src\main\AndroidManifest.xml ====================
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.memora_application">

    <!-- Required permissions for notifications and calls -->
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.RECORD_AUDIO" />
    <uses-permission android:name="android.permission.MODIFY_AUDIO_SETTINGS" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.WAKE_LOCK" />

    <!-- Notification permissions -->
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
    <uses-permission android:name="android.permission.SCHEDULE_EXACT_ALARM" />

    <!-- Full-screen intent permission for incoming calls (Android 12+) -->
    <uses-permission android:name="android.permission.USE_FULL_SCREEN_INTENT" />

    <application
        android:name="${applicationName}"
        android:label="Memora"
        android:icon="@mipmap/ic_launcher">

        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|screenLayout|locale|layoutDirection|fontScale|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize"
            android:showWhenLocked="true"
            android:turnScreenOn="true">

            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <!-- Default notification channel (used by flutter_local_notifications + FCM fallback) -->
        <meta-data
            android:name="com.google.firebase.messaging.default_notification_channel_id"
            android:value="memora_basic_channel" />

        <!-- Required for Flutter v2 embedding -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
</manifest>


==================== FILE: android\app\src\main\java\io\flutter\plugins\GeneratedPluginRegistrant.java ====================
package io.flutter.plugins;

import androidx.annotation.Keep;
import androidx.annotation.NonNull;
import io.flutter.Log;

import io.flutter.embedding.engine.FlutterEngine;

/**
 * Generated file. Do not edit.
 * This file is generated by the Flutter tool based on the
 * plugins that support the Android platform.
 */
@Keep
public final class GeneratedPluginRegistrant {
  private static final String TAG = "GeneratedPluginRegistrant";
  public static void registerWith(@NonNull FlutterEngine flutterEngine) {
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.core.FlutterFirebaseCorePlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin firebase_core, io.flutter.plugins.firebase.core.FlutterFirebaseCorePlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.messaging.FlutterFirebaseMessagingPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin firebase_messaging, io.flutter.plugins.firebase.messaging.FlutterFirebaseMessagingPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new com.dexterous.flutterlocalnotifications.FlutterLocalNotificationsPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin flutter_local_notifications, com.dexterous.flutterlocalnotifications.FlutterLocalNotificationsPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new com.baseflow.permissionhandler.PermissionHandlerPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin permission_handler_android, com.baseflow.permissionhandler.PermissionHandlerPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.sharedpreferences.SharedPreferencesPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin shared_preferences_android, io.flutter.plugins.sharedpreferences.SharedPreferencesPlugin", e);
    }
  }
}


==================== FILE: android\app\src\main\kotlin\com\example\memora_application\MainActivity.kt ====================
package com.example.memora_application

import io.flutter.embedding.android.FlutterActivity
import io.flutter.embedding.engine.FlutterEngine
import io.flutter.plugin.common.MethodChannel

class MainActivity: FlutterActivity() {
    // This channel name must match the one used in your Dart code.
    private val CHANNEL = "com.example.memora_application/native"

    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {
        super.configureFlutterEngine(flutterEngine)
        MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler {
            call, result ->
            if (call.method == "sendToBackground") {
                moveTaskToBack(true) // This is the native Android code to send the app to the background.
                result.success(null)
            } else {
                result.notImplemented()
            }
        }
    }
}

==================== FILE: android\app\src\main\res\drawable\launch_background.xml ====================
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>


==================== FILE: android\app\src\main\res\drawable-v21\launch_background.xml ====================
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>


==================== FILE: android\app\src\main\res\values\styles.xml ====================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>


==================== FILE: android\app\src\main\res\values-night\styles.xml ====================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>


==================== FILE: android\app\src\profile\AndroidManifest.xml ====================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>


==================== FILE: documents\mobile_protocol.txt ====================
Backend Integration Specification: MCI Voice Assistant (Multi-User Version)
1. System Overview

This document outlines the API and logic required for the backend agent system to integrate with the MCI Voice Assistant mobile app. The system now supports multiple, unique users, each identified by their phone number.

2. Core Concepts

user_phone / user_id: The primary and unique identifier for a user.
It is always provided in the normalized international format (e.g., 972547778005).

fcm_token: The unique registration token for the app on a specific device, provided by Firebase. This token is essential for sending push notifications and can change over time.

3. Database Requirements

The backend uses two main tables for user and device management.

**Table: `users`**
| Column     | Type        | Notes                                                        |
| :--------- | :---------- | :----------------------------------------------------------- |
| user_phone | VARCHAR(20) | Primary Key. The user's unique, normalized phone number.     |
| name       | VARCHAR(255)| The user's provided name.                                    |
| gender     | VARCHAR(10) | The user's gender ('male', 'female', or 'other').            |

**Table: `devices`**
| Column    | Type        | Notes                               |
| :-------- | :---------- | :---------------------------------- |
| `device_id` | `SERIAL`    | Primary Key.                        |
| `user_id` | `VARCHAR(20)` | Foreign Key to `users.user_phone`.  |
| `fcm_token` | `TEXT`      | Firebase Cloud Messaging token.     |

4. API Endpoints

The backend must expose the following HTTP POST endpoints. All request and response bodies are in JSON format.

Endpoint 1: First-Time User Registration

This endpoint is used by the mobile app ONLY when a user registers for the first time.

Method: POST
Path: /register-user
Request Body (JSON):
{
  "user_phone": "972541234567",
  "name": "ישראל ישראלי",
  "gender": "male",
  "language": "he", // Optional: "he" or "en". Defaults to "he" if not provided.
  "fcm_token": "dEgPUpGiSd64ytltFCdIWM:APA91b..."
}

Backend Logic:
- Receive the user data.
- Find or create a user in the `users` table based on `user_phone`.
- Create or update a corresponding record in the `devices` table, associating the `fcm_token` with the `user_phone`.
- This ensures that if a user registers on a new device, the new FCM token is captured without overwriting their core profile.

Success Response:
Status Code: 200 OK
Body (JSON): { "status": "success", "message": "User registered or updated successfully." }


Endpoint 2: Session Initiation (for Existing Users)

This endpoint is used every time a registered user opens the app. It syncs their data and FCM token.

Method: POST
Path: /initiate-session
Request Body (JSON):
{
  "user_phone": "972541234567",
  "name": "ישראל ישראלי",
  "gender": "male",
  "language": "he", // Optional: "he" or "en". Defaults to "he" if not provided.
  "fcm_token": "dEgPUpGiSd64ytltFCdIWM:APA91b..."
}

Backend Logic:
- Receive the user data.
- This logic is identical to the `/register-user` endpoint. It finds the user by `user_phone` and updates their `name`, `gender`, and ensures the `fcm_token` in the `devices` table is current for that user.

Success Response:
Status Code: 200 OK
Body (JSON): { "status": "success", "message": "Session initiated and user data synchronized." }


Endpoint 3: Conversation Processing

Path: /voice/process
Request Body (JSON):
{
  "user_id": "972541234567", // Normalized phone number
  "message": "The text transcribed from the user's speech.",
  "audio_data": null
}


Endpoint 4: Agent-Initiated Call Answered

Path: /voice/call-answered
Request Body (JSON): { "user_id": "972541234567" }


Endpoint 5: Agent-Initiated Call Declined

Path: /voice/call-declined
Request Body (JSON): { "user_id": "972541234567" }


5. Workflow Walkthroughs

Flow A: First-Time User Registration
1. A new user opens the app and sees the registration screen.
2. The user enters their name, gender, and phone number.
3. The app normalizes the phone number to `972541234567`.
4. The app saves the full profile to local storage.
5. The app gets a unique `fcm_token` from Firebase.
6. The app sends a POST request to `/register-user` with the following body:
   ```json
   {
     "user_phone": "972541234567",
     "name": "ישראלה ישראלי",
     "gender": "female",
     "language": "he",
     "fcm_token": "dEgPUpGiSd6..."
   }
   ```
7. The backend performs an UPSERT operation. Since the user is new, they are inserted into the `users` table. The user proceeds to the HomeScreen.

Flow B: Existing User App Start (Session Initiation)
1. A registered user opens the app.
2. The app reads the saved User Profile (`name`, `gender`, `phone`) from its local storage.
3. The app gets the latest `fcm_token` from Firebase.
4. The app sends a POST request to `/initiate-session` with the following body:
   ```json
   {
     "user_phone": "972541234567",
     "name": "ישראלה ישראלי",
     "gender": "female",
     "language": "he",
     "fcm_token": "dEgPUpGiSd6..."
   }
   ```
5. The backend performs an UPSERT on the `users` table, ensuring the user's data and FCM token are up-to-date.
6. The app proceeds to the HomeScreen.

Flow C: User-Initiated Conversation
1. The user speaks a message. The app transcribes it.
2. The app sends a POST request to /voice/process with the saved user_id and the transcribed message.
3. The backend processes the message and returns the agent's reply.
4. The app speaks the reply. The conversation continues until the user closes the app.
5. Upon closing the app, the app sends one final POST to /voice/process with the message "USER_CLOSED_APP".

Flow D: Agent-Initiated Conversation (Reminder/Ring)
1. An event triggers the agent on the backend for a specific user (identified by user_phone, e.g., 972541234567).
2. The backend queries the users table using 972541234567 to retrieve the corresponding fcm_token.
3. The backend authenticates with Google (using its Service Account key) to get a temporary OAuth 2.0 access token.
4. The backend constructs and sends an HTTP V1 FCM request to Google's servers.
   URL: https://fcm.googleapis.com/v1/projects/mci-assistant/messages:send
   Headers:
     Content-Type: application/json
     Authorization: Bearer <Generated_Access_Token>
   Body (JSON):
   {
     "message": {
       "token": "THE_FCM_TOKEN_FROM_DATABASE",
       "data": {
         "title": "תזכורת חשובה", // The title for the notification UI
         "body": "שלום, זה הזמן לקחת את התרופה שלך." // The text the app will speak when the user answers
       }
     }
   }
5. The mobile app receives the push notification and displays a full-screen "incoming call" interface.
6. User Interaction with "Incoming Call":
   - If the user "answers" the call:
     a. The app first sends a POST request to /voice/call-answered with the `user_id`.
     b. The app then navigates to the main conversation screen.
     c. The app speaks the `body` content from the FCM notification.
     d. The conversation then continues as described in Flow C, starting with the app listening for the user's response.
   - If the user "declines" the call (e.g., presses a decline button):
     a. The app sends a POST request to /voice/call-declined with the `user_id`.
     b. The incoming call screen is dismissed. No further conversation flow is initiated by this event.
   - If the user does not answer (No Answer):
     a. The app does nothing. It does not send any request to the backend.
     b. The backend is responsible for handling this scenario. After sending the notification, the backend will start a timer. If it doesn't receive a `/voice/call-answered` or `/voice/call-declined` request within a configured timeout period, it will assume the user did not answer and proceed with its internal logic (e.g., log a missed notification, retry, or escalate to caregivers).

6. Backend Server Address
Configured Base URL: http://memora.aigents.co.il


